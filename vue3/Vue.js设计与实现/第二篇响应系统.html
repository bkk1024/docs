<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <link rel="icon" href="/docs/icon.png"><title>第二篇 响应系统 | 二师弟的学习笔记</title><meta name="description" content="二师弟的学习笔记">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/docs/assets/style-6d00d8ff.css" as="style"><link rel="stylesheet" href="/docs/assets/style-6d00d8ff.css">
    <link rel="modulepreload" href="/docs/assets/app-0ea0852b.js"><link rel="modulepreload" href="/docs/assets/framework-4f54a744.js"><link rel="modulepreload" href="/docs/assets/第二篇响应系统.html-faa33985.js"><link rel="modulepreload" href="/docs/assets/第二篇响应系统.html-0241c283.js"><link rel="prefetch" href="/docs/assets/index.html-873919fc.js" as="script"><link rel="prefetch" href="/docs/assets/vite3.html-d13a01c0.js" as="script"><link rel="prefetch" href="/docs/assets/webpack5.html-c5d53893.js" as="script"><link rel="prefetch" href="/docs/assets/phaser3.html-4625842b.js" as="script"><link rel="prefetch" href="/docs/assets/css.html-d0f02439.js" as="script"><link rel="prefetch" href="/docs/assets/echarts.html-89479e1e.js" as="script"><link rel="prefetch" href="/docs/assets/elementui.html-5297a3c5.js" as="script"><link rel="prefetch" href="/docs/assets/html.html-5b76f10d.js" as="script"><link rel="prefetch" href="/docs/assets/js.html-28c9c2f0.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-a89623a5.js" as="script"><link rel="prefetch" href="/docs/assets/uni-app.html-033fa626.js" as="script"><link rel="prefetch" href="/docs/assets/vue2.html-40efae7e.js" as="script"><link rel="prefetch" href="/docs/assets/vue3.html-465e0201.js" as="script"><link rel="prefetch" href="/docs/assets/vuex.html-1398b4b1.js" as="script"><link rel="prefetch" href="/docs/assets/webpack.html-db7c9f84.js" as="script"><link rel="prefetch" href="/docs/assets/WebSocket.html-cd585a4d.js" as="script"><link rel="prefetch" href="/docs/assets/js方法.html-8dbf21ec.js" as="script"><link rel="prefetch" href="/docs/assets/js知识要点.html-f2011264.js" as="script"><link rel="prefetch" href="/docs/assets/事件循环.html-754a7f88.js" as="script"><link rel="prefetch" href="/docs/assets/属性描述符.html-6e334454.js" as="script"><link rel="prefetch" href="/docs/assets/文件上传.html-67af08e4.js" as="script"><link rel="prefetch" href="/docs/assets/浏览器渲染原理.html-d31fa9b5.js" as="script"><link rel="prefetch" href="/docs/assets/轮询.html-7068da83.js" as="script"><link rel="prefetch" href="/docs/assets/leetcode算法.html-fa89f797.js" as="script"><link rel="prefetch" href="/docs/assets/nestjs8.html-b8bc19ac.js" as="script"><link rel="prefetch" href="/docs/assets/nestjs博客接口案例.html-b53faf37.js" as="script"><link rel="prefetch" href="/docs/assets/nodejs.html-e5252953.js" as="script"><link rel="prefetch" href="/docs/assets/nodejs和express配合前端history模式.html-a773c754.js" as="script"><link rel="prefetch" href="/docs/assets/nvm.html-b8822afa.js" as="script"><link rel="prefetch" href="/docs/assets/pm2.html-17ac66b3.js" as="script"><link rel="prefetch" href="/docs/assets/项目笔记.html-82ac6c2d.js" as="script"><link rel="prefetch" href="/docs/assets/FastAPI.html-2767ac68.js" as="script"><link rel="prefetch" href="/docs/assets/excel.html-c6d7c8e8.js" as="script"><link rel="prefetch" href="/docs/assets/mongoDB.html-00172f1d.js" as="script"><link rel="prefetch" href="/docs/assets/selenium.html-e72897fa.js" as="script"><link rel="prefetch" href="/docs/assets/并发编程.html-15ed4b91.js" as="script"><link rel="prefetch" href="/docs/assets/日志模块.html-c9d55a69.js" as="script"><link rel="prefetch" href="/docs/assets/craco.html-4dcc1aa9.js" as="script"><link rel="prefetch" href="/docs/assets/react18.html-973190cf.js" as="script"><link rel="prefetch" href="/docs/assets/react使用lottie.html-79e48e92.js" as="script"><link rel="prefetch" href="/docs/assets/react使用svg.html-840f1048.js" as="script"><link rel="prefetch" href="/docs/assets/DOM和BOM内置对象.html-fa919f4f.js" as="script"><link rel="prefetch" href="/docs/assets/Decorator装饰器.html-0c6124dc.js" as="script"><link rel="prefetch" href="/docs/assets/Mixins混入.html-afa10a7b.js" as="script"><link rel="prefetch" href="/docs/assets/Object和object.html-82bf395b.js" as="script"><link rel="prefetch" href="/docs/assets/Partial、Pick、Record、Readonly.html-b36d334c.js" as="script"><link rel="prefetch" href="/docs/assets/Proxy和Reflect.html-e75ba7f9.js" as="script"><link rel="prefetch" href="/docs/assets/any和void和never.html-812dee82.js" as="script"><link rel="prefetch" href="/docs/assets/infer.html-3e1c5b47.js" as="script"><link rel="prefetch" href="/docs/assets/interface接口.html-cafcbbaa.js" as="script"><link rel="prefetch" href="/docs/assets/namespace命名空间.html-2a194e1f.js" as="script"><link rel="prefetch" href="/docs/assets/reflect-metadata元数据.html-ca5dbf44.js" as="script"><link rel="prefetch" href="/docs/assets/tsconfig.json配置.html-c7ce0fb7.js" as="script"><link rel="prefetch" href="/docs/assets/ts使用Promise.html-82eaac6d.js" as="script"><link rel="prefetch" href="/docs/assets/ts基本内容.html-2c0fec89.js" as="script"><link rel="prefetch" href="/docs/assets/ts编写发布订阅模式.html-962b2645.js" as="script"><link rel="prefetch" href="/docs/assets/声明文件d.ts.html-0ab897e3.js" as="script"><link rel="prefetch" href="/docs/assets/泛型.html-c779c98d.js" as="script"><link rel="prefetch" href="/docs/assets/类型兼容.html-88f7352c.js" as="script"><link rel="prefetch" href="/docs/assets/axios.html-a980e971.js" as="script"><link rel="prefetch" href="/docs/assets/pinia.html-11694eb7.js" as="script"><link rel="prefetch" href="/docs/assets/vue-router.html-15154da2.js" as="script"><link rel="prefetch" href="/docs/assets/vue3-vite-electron.html-b737965b.js" as="script"><link rel="prefetch" href="/docs/assets/vue3一些自定义指令.html-f1303b63.js" as="script"><link rel="prefetch" href="/docs/assets/vue3其他笔记.html-a901a8ef.js" as="script"><link rel="prefetch" href="/docs/assets/vue3学习笔记.html-6069da80.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress.html-064a3f4c.js" as="script"><link rel="prefetch" href="/docs/assets/vue常见优化手段.html-5f03036c.js" as="script"><link rel="prefetch" href="/docs/assets/前言.html-c1e2974c.js" as="script"><link rel="prefetch" href="/docs/assets/第一篇框架设计概览.html-e4e87416.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-f04ced3e.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-007e3d49.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-482a2c47.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-5ec05c94.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-4ba11b22.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-d6e43004.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-5d079a57.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-2225520e.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-b1f72b95.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9084f6b7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-c11822d4.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9db0214d.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ccc17d87.js" as="script"><link rel="prefetch" href="/docs/assets/vite3.html-b95b7af5.js" as="script"><link rel="prefetch" href="/docs/assets/webpack5.html-f837636b.js" as="script"><link rel="prefetch" href="/docs/assets/phaser3.html-ed12c05d.js" as="script"><link rel="prefetch" href="/docs/assets/css.html-32556baf.js" as="script"><link rel="prefetch" href="/docs/assets/echarts.html-88d862ff.js" as="script"><link rel="prefetch" href="/docs/assets/elementui.html-15eb9d4d.js" as="script"><link rel="prefetch" href="/docs/assets/html.html-2b3cb614.js" as="script"><link rel="prefetch" href="/docs/assets/js.html-29a95c5e.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-2d6fc1ec.js" as="script"><link rel="prefetch" href="/docs/assets/uni-app.html-61008000.js" as="script"><link rel="prefetch" href="/docs/assets/vue2.html-a012d90f.js" as="script"><link rel="prefetch" href="/docs/assets/vue3.html-f8895c8e.js" as="script"><link rel="prefetch" href="/docs/assets/vuex.html-57a43e3d.js" as="script"><link rel="prefetch" href="/docs/assets/webpack.html-c10a1903.js" as="script"><link rel="prefetch" href="/docs/assets/WebSocket.html-ee5ee0b6.js" as="script"><link rel="prefetch" href="/docs/assets/js方法.html-826b1713.js" as="script"><link rel="prefetch" href="/docs/assets/js知识要点.html-c3b21c72.js" as="script"><link rel="prefetch" href="/docs/assets/事件循环.html-fd1822db.js" as="script"><link rel="prefetch" href="/docs/assets/属性描述符.html-bde26b2a.js" as="script"><link rel="prefetch" href="/docs/assets/文件上传.html-14d341e7.js" as="script"><link rel="prefetch" href="/docs/assets/浏览器渲染原理.html-1edfadbf.js" as="script"><link rel="prefetch" href="/docs/assets/轮询.html-e55a71f2.js" as="script"><link rel="prefetch" href="/docs/assets/leetcode算法.html-d0bf9df8.js" as="script"><link rel="prefetch" href="/docs/assets/nestjs8.html-69be4e22.js" as="script"><link rel="prefetch" href="/docs/assets/nestjs博客接口案例.html-2bb8adab.js" as="script"><link rel="prefetch" href="/docs/assets/nodejs.html-a9696c41.js" as="script"><link rel="prefetch" href="/docs/assets/nodejs和express配合前端history模式.html-c9a26dac.js" as="script"><link rel="prefetch" href="/docs/assets/nvm.html-f3381fc6.js" as="script"><link rel="prefetch" href="/docs/assets/pm2.html-e8b31ba0.js" as="script"><link rel="prefetch" href="/docs/assets/项目笔记.html-4f4c4986.js" as="script"><link rel="prefetch" href="/docs/assets/FastAPI.html-e843e479.js" as="script"><link rel="prefetch" href="/docs/assets/excel.html-4592f699.js" as="script"><link rel="prefetch" href="/docs/assets/mongoDB.html-168c1dad.js" as="script"><link rel="prefetch" href="/docs/assets/selenium.html-47a64703.js" as="script"><link rel="prefetch" href="/docs/assets/并发编程.html-b19fb1fa.js" as="script"><link rel="prefetch" href="/docs/assets/日志模块.html-5cf3b3c1.js" as="script"><link rel="prefetch" href="/docs/assets/craco.html-de63a6cc.js" as="script"><link rel="prefetch" href="/docs/assets/react18.html-f0c244aa.js" as="script"><link rel="prefetch" href="/docs/assets/react使用lottie.html-f42ee1db.js" as="script"><link rel="prefetch" href="/docs/assets/react使用svg.html-a7bb6f7d.js" as="script"><link rel="prefetch" href="/docs/assets/DOM和BOM内置对象.html-cb757473.js" as="script"><link rel="prefetch" href="/docs/assets/Decorator装饰器.html-054dcadb.js" as="script"><link rel="prefetch" href="/docs/assets/Mixins混入.html-8533960b.js" as="script"><link rel="prefetch" href="/docs/assets/Object和object.html-9830d052.js" as="script"><link rel="prefetch" href="/docs/assets/Partial、Pick、Record、Readonly.html-e52803be.js" as="script"><link rel="prefetch" href="/docs/assets/Proxy和Reflect.html-3b2aa239.js" as="script"><link rel="prefetch" href="/docs/assets/any和void和never.html-5d23b979.js" as="script"><link rel="prefetch" href="/docs/assets/infer.html-12c3e7cf.js" as="script"><link rel="prefetch" href="/docs/assets/interface接口.html-458d3c87.js" as="script"><link rel="prefetch" href="/docs/assets/namespace命名空间.html-ba48fb9e.js" as="script"><link rel="prefetch" href="/docs/assets/reflect-metadata元数据.html-b3f40cbb.js" as="script"><link rel="prefetch" href="/docs/assets/tsconfig.json配置.html-0d4ad185.js" as="script"><link rel="prefetch" href="/docs/assets/ts使用Promise.html-310b4aec.js" as="script"><link rel="prefetch" href="/docs/assets/ts基本内容.html-4b5230fb.js" as="script"><link rel="prefetch" href="/docs/assets/ts编写发布订阅模式.html-e5d4fdd6.js" as="script"><link rel="prefetch" href="/docs/assets/声明文件d.ts.html-bc022730.js" as="script"><link rel="prefetch" href="/docs/assets/泛型.html-038c90c2.js" as="script"><link rel="prefetch" href="/docs/assets/类型兼容.html-f8928873.js" as="script"><link rel="prefetch" href="/docs/assets/axios.html-dd2f39ad.js" as="script"><link rel="prefetch" href="/docs/assets/pinia.html-9db217a3.js" as="script"><link rel="prefetch" href="/docs/assets/vue-router.html-b4b7800c.js" as="script"><link rel="prefetch" href="/docs/assets/vue3-vite-electron.html-16659694.js" as="script"><link rel="prefetch" href="/docs/assets/vue3一些自定义指令.html-8ae6543c.js" as="script"><link rel="prefetch" href="/docs/assets/vue3其他笔记.html-a35bf2f8.js" as="script"><link rel="prefetch" href="/docs/assets/vue3学习笔记.html-e385610c.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress.html-020119f9.js" as="script"><link rel="prefetch" href="/docs/assets/vue常见优化手段.html-06f0953d.js" as="script"><link rel="prefetch" href="/docs/assets/前言.html-7983b7b7.js" as="script"><link rel="prefetch" href="/docs/assets/第一篇框架设计概览.html-59515c3e.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-e3821f77.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-aa8ddcf0.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-a554b704.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-02f7b1cd.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-7d3e4fca.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-2a9f6d0f.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-1e0216f7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-c2818869.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-58785519.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-37eb7747.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-af439866.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ef04918a.js" as="script"><link rel="prefetch" href="/docs/assets/photoswipe.esm-6e6cbe40.js" as="script"><link rel="prefetch" href="/docs/assets/SearchResult-fd9b7c3b.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/docs/" class="brand"><img class="logo" src="/docs/icon.png" alt="二师弟的学习笔记"><!----><span class="site-name hide-in-pad">二师弟的学习笔记</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/docs/" class="nav-link" aria-label="首页"><!---->首页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="语言"><span class="title"><!---->语言</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JavaScript</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/js/js%E6%96%B9%E6%B3%95.html" class="nav-link" aria-label="js语言用法"><!---->js语言用法<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>TypeScript</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/ts/ts%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9.html" class="nav-link" aria-label="ts语言用法"><!---->ts语言用法<!----></a></li><li class="dropdown-subitem"><a href="/docs/ts/tsconfig.json%E9%85%8D%E7%BD%AE.html" class="nav-link" aria-label="ts相关文件"><!---->ts相关文件<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>python</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/python/selenium.html" class="nav-link" aria-label="python爬虫"><!---->python爬虫<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="打包工具"><span class="title"><!---->打包工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/build-tools/vite3.html" class="nav-link" aria-label="vite3"><!---->vite3<!----></a></li><li class="dropdown-item"><a href="/docs/build-tools/webpack5.html" class="nav-link" aria-label="webpack5"><!---->webpack5<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Node"><span class="title"><!---->Node</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>NodeJS</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/node/nvm.html" class="nav-link" aria-label="nvm"><!---->nvm<!----></a></li><li class="dropdown-subitem"><a href="/docs/node/nodejs.html" class="nav-link" aria-label="nodejs"><!---->nodejs<!----></a></li><li class="dropdown-subitem"><a href="/docs/node/pm2.html" class="nav-link" aria-label="pm2"><!---->pm2<!----></a></li><li class="dropdown-subitem"><a href="/docs/node/nodejs%E5%92%8Cexpress%E9%85%8D%E5%90%88%E5%89%8D%E7%AB%AFhistory%E6%A8%A1%E5%BC%8F.html" class="nav-link" aria-label="nodejs+express+history"><!---->nodejs+express+history<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>NestJS</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/node/nestjs8.html" class="nav-link" aria-label="nestjs"><!---->nestjs<!----></a></li><li class="dropdown-subitem"><a href="/docs/node/nestjs%E5%8D%9A%E5%AE%A2%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B.html" class="nav-link" aria-label="nestjs案例"><!---->nestjs案例<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Vue"><span class="title"><!---->Vue</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Vue3</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/vue3/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" class="nav-link" aria-label="vue3学习笔记"><!---->vue3学习笔记<!----></a></li><li class="dropdown-subitem"><a href="/docs/vue3/vue3%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0.html" class="nav-link" aria-label="vue3其他笔记"><!---->vue3其他笔记<!----></a></li><li class="dropdown-subitem"><a href="/docs/vue3/vue%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5.html" class="nav-link" aria-label="优化"><!---->优化<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>VueRouter</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/vue3/vue-router.html" class="nav-link" aria-label="vue-router"><!---->vue-router<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>状态管理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/vue3/pinia.html" class="nav-link" aria-label="pinia"><!---->pinia<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>书籍阅读</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%89%8D%E8%A8%80.html" class="nav-link" aria-label="Vue.js设计与实现"><!---->Vue.js设计与实现<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>其他</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/vue3/axios.html" class="nav-link" aria-label="axios"><!---->axios<!----></a></li><li class="dropdown-subitem"><a href="/docs/vue3/vue3-vite-electron.html" class="nav-link" aria-label="electron桌面应用"><!---->electron桌面应用<!----></a></li><li class="dropdown-subitem"><a href="/docs/vue3/vuepress.html" class="nav-link" aria-label="VuePress"><!---->VuePress<!----></a></li><li class="dropdown-subitem"><a href="/docs/vue3/vue3%E4%B8%80%E4%BA%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html" class="nav-link" aria-label="vue3一些自定义指令"><!---->vue3一些自定义指令<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="React"><span class="title"><!---->React</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>React18</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/react/react18.html" class="nav-link" aria-label="react18学习笔记"><!---->react18学习笔记<!----></a></li><li class="dropdown-subitem"><a href="/docs/react/react%E4%BD%BF%E7%94%A8svg.html" class="nav-link" aria-label="react使用svg"><!---->react使用svg<!----></a></li><li class="dropdown-subitem"><a href="/docs/react/react%E4%BD%BF%E7%94%A8lottie.html" class="nav-link" aria-label="react使用lottie"><!---->react使用lottie<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>其他</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/react/craco.html" class="nav-link" aria-label="craco"><!---->craco<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/leetcode/leetcode%E7%AE%97%E6%B3%95.html" class="nav-link" aria-label="LeetCode"><!---->LeetCode<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/games/phaser3.html" class="nav-link" aria-label="游戏"><!---->游戏<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/interview/" class="nav-link" aria-label="面试"><!---->面试<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/bkk1024/docs" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Vue3</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">VueRouter</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">状态管理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Vue.js设计与实现</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%89%8D%E8%A8%80.html" class="nav-link sidebar-link sidebar-page" aria-label="前言"><!---->前言<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A7%88.html" class="nav-link sidebar-link sidebar-page" aria-label="第一篇 框架设计概览"><!---->第一篇 框架设计概览<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第二篇 响应系统"><!---->第二篇 响应系统<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第四章-响应系统的作用与实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第四章 响应系统的作用与实现"><!---->第四章 响应系统的作用与实现<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-1-响应式数据与副作用函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 响应式数据与副作用函数"><!---->4.1 响应式数据与副作用函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-2-响应式数据的基本实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 响应式数据的基本实现"><!---->4.2 响应式数据的基本实现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-3-设计一个完善的响应系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 设计一个完善的响应系统"><!---->4.3 设计一个完善的响应系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-4-分支切换与cleanup" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 分支切换与cleanup"><!---->4.4 分支切换与cleanup<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-5-嵌套的-effect-与-effect-栈" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5 嵌套的 effect 与 effect 栈"><!---->4.5 嵌套的 effect 与 effect 栈<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-6-避免无限递归循环" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.6 避免无限递归循环"><!---->4.6 避免无限递归循环<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-7-调度执行" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.7 调度执行"><!---->4.7 调度执行<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-8-计算属性-computed-与-lazy" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.8 计算属性 computed 与 lazy"><!---->4.8 计算属性 computed 与 lazy<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-9-watch-的实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.9 watch 的实现原理"><!---->4.9 watch 的实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-10-立即执行的-watch-与回调执行时机" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.10 立即执行的 watch 与回调执行时机"><!---->4.10 立即执行的 watch 与回调执行时机<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-11-过期的副作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.11 过期的副作用"><!---->4.11 过期的副作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第四章的完整代码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第四章的完整代码"><!---->第四章的完整代码<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第五章-非原始值的响应式方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第五章 非原始值的响应式方案"><!---->第五章 非原始值的响应式方案<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-1-理解-proxy-和-reflect" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1 理解 Proxy 和 Reflect"><!---->5.1 理解 Proxy 和 Reflect<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-2-javascript-对象及-proxy-的工作原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2 JavaScript 对象及 Proxy 的工作原理"><!---->5.2 JavaScript 对象及 Proxy 的工作原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-3-如何代理-object" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3 如何代理 Object"><!---->5.3 如何代理 Object<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第六章-原始值的响应式方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第六章 原始值的响应式方案"><!---->第六章 原始值的响应式方案<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">其他</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第二篇 响应系统</h1><div class="page-info"><!----><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-03-14T10:11:26.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<!----></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第四章-响应系统的作用与实现" class="router-link-active router-link-exact-active toc-link level2">第四章 响应系统的作用与实现</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-1-响应式数据与副作用函数" class="router-link-active router-link-exact-active toc-link level3">4.1 响应式数据与副作用函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-2-响应式数据的基本实现" class="router-link-active router-link-exact-active toc-link level3">4.2 响应式数据的基本实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-3-设计一个完善的响应系统" class="router-link-active router-link-exact-active toc-link level3">4.3 设计一个完善的响应系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-4-分支切换与cleanup" class="router-link-active router-link-exact-active toc-link level3">4.4 分支切换与cleanup</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-5-嵌套的-effect-与-effect-栈" class="router-link-active router-link-exact-active toc-link level3">4.5 嵌套的 effect 与 effect 栈</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-6-避免无限递归循环" class="router-link-active router-link-exact-active toc-link level3">4.6 避免无限递归循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-7-调度执行" class="router-link-active router-link-exact-active toc-link level3">4.7 调度执行</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-8-计算属性-computed-与-lazy" class="router-link-active router-link-exact-active toc-link level3">4.8 计算属性 computed 与 lazy</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-9-watch-的实现原理" class="router-link-active router-link-exact-active toc-link level3">4.9 watch 的实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-10-立即执行的-watch-与回调执行时机" class="router-link-active router-link-exact-active toc-link level3">4.10 立即执行的 watch 与回调执行时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-11-过期的副作用" class="router-link-active router-link-exact-active toc-link level3">4.11 过期的副作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第四章的完整代码" class="router-link-active router-link-exact-active toc-link level3">第四章的完整代码</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第五章-非原始值的响应式方案" class="router-link-active router-link-exact-active toc-link level2">第五章 非原始值的响应式方案</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-1-理解-proxy-和-reflect" class="router-link-active router-link-exact-active toc-link level3">5.1 理解 Proxy 和 Reflect</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-2-javascript-对象及-proxy-的工作原理" class="router-link-active router-link-exact-active toc-link level3">5.2 JavaScript 对象及 Proxy 的工作原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_5-3-如何代理-object" class="router-link-active router-link-exact-active toc-link level3">5.3 如何代理 Object</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#第六章-原始值的响应式方案" class="router-link-active router-link-exact-active toc-link level2">第六章 原始值的响应式方案</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="第二篇-响应系统" tabindex="-1"><a class="header-anchor" href="#第二篇-响应系统" aria-hidden="true">#</a> 第二篇 响应系统</h1><h2 id="第四章-响应系统的作用与实现" tabindex="-1"><a class="header-anchor" href="#第四章-响应系统的作用与实现" aria-hidden="true">#</a> 第四章 响应系统的作用与实现</h2><h3 id="_4-1-响应式数据与副作用函数" tabindex="-1"><a class="header-anchor" href="#_4-1-响应式数据与副作用函数" aria-hidden="true">#</a> 4.1 响应式数据与副作用函数</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.1 响应式数据与副作用函数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>副作用函数</code>：当一个函数的执行会直接或间接影响其他函数的执行时，这个函数就是一个副作用函数。例子如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&quot;body&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，<em>effect()</em> 函数的执行会修改 body 的文本内容，但是这个文本内容并不是只有 <em>effect()</em> 函数才能修改的，因此这个函数的执行会直接或间接的影响其他函数的执行，它产生了副作用。其他例子如一个函数修改了一个全局变量，那么这个函数也是一个副作用函数。</p><p><code>响应式数据</code>：当这个数据变化时，依赖于它的函数或者说副作用函数会自动的重新执行，那么这个数据就是响应式数据。如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> count
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <em>count</em> 的值变化时，<em>effect()</em> 函数如果会自动执行的话，那么 <em>count</em> 就是一个响应式数据。</p><h3 id="_4-2-响应式数据的基本实现" tabindex="-1"><a class="header-anchor" href="#_4-2-响应式数据的基本实现" aria-hidden="true">#</a> 4.2 响应式数据的基本实现</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.2 响应式数据的基本实现<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>整体思路分为两步，以上面的代码举例：</p><ol><li>读取到 <em>count</em> 时，将函数 <em>effect</em> 保存起来</li><li>当再次设置 <em>count</em> 时，将函数 <em>effect</em> 取出来执行</li></ol><p>这两步的关键点就在于拦截数据，即我们能手动控制数据的读取(<code>get</code>)和设置(<code>set</code>)两个操作。在 ES2015 前，我们只能通过<a href="/docs/js/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.html" class="">Object.defineProperty()</a>函数实现，也就是 Vue2 采用的方式，但是在 ES2015+ 后，我们可以使用代理对象<a href="/docs/ts/Proxy%E5%92%8CReflect.html" class="">Proxy</a>来实现了，也就是 Vue3 采用的方式。</p><p>这里我们采用<code>Proxy</code>来实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储副作用函数</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存副作用函数</span>
    bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码还有很多缺陷，但是也是一个简单的实现了。</p><h3 id="_4-3-设计一个完善的响应系统" tabindex="-1"><a class="header-anchor" href="#_4-3-设计一个完善的响应系统" aria-hidden="true">#</a> 4.3 设计一个完善的响应系统</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.3 设计一个完善的响应系统<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>根据上一节的代码，我们要解决的第一个问题就是副作用函数，因为它不一定就是<em>effect</em>，也可能是别的名字，因此我们需要正确的收集副作用函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 存储副作用函数</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当调用 effect 时，注册副作用函数</span>
  activeEffect <span class="token operator">=</span> fn
  <span class="token comment">// 执行一次副作用函数</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成这一步后，我们就需要使用这个<em>effect</em>函数来注册副作用函数了。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 保存副作用函数</span>
      bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ok，完成这两步后，我们先试试看：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">effect</span><span class="token punctuation">(</span>myEff<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
</code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，目前这个副作用函数的名字为<em>myEff</em>，我们使用<em>effect</em>函数去注册它后，代码依然能正常运行。但是，它并不是没有问题，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// dataProxy 中并没有 name 属性</span>
dataProxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// 还是会输出 hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，当我们给一个并不存在的属性赋值时，还是会触发副作用函数，这显然是不合理的，因此，我们需要对存储副作用函数的<code>const bucket = new Set()</code>进行重新设计。</p><details class="hint-container details"><summary>设计 bucket 数据结构的一点思考</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中存在三个角色：</p><ol><li>被操作的对象：<code>dataProxy</code></li><li>被操作的属性，或者说字段：<code>text</code></li><li>副作用函数：<code>myEff</code></li></ol><p>它们之间的关系应该是如下的：<code>dataProxy -&gt; text -&gt; myEff</code>，即<strong>由 target 保存 key，由 key 保存 activeEffect</strong>（这里的 target 是<code>Proxy</code>中<code>get</code>和<code>set</code>的第一个参数，即代理的对象本身，key 是第二个参数，即操作的对象中的哪个字段，activeEffect 是副作用函数）。</p><p>如果是多个函数操作同一个字段的话，关系就是如下：<code>target -&gt; key -&gt; (activeEffect1, activeEffect2, ...)</code>，有点像一个树形结构：</p><div style="text-align:center;"><p><img src="/docs/assets/image-20230314224201381-b6f3e1f3.png" alt="image-20230314224201381"></p></div><p>如果是多个字段对应同一个副作用函数、多个字段对应多个副作用函数等情况都与此类似。</p><p>总的来说，一个 target 可以对应 0-∞ 个字段，每个字段可以对应 0-∞ 个副作用函数，是一个此类的属性结构。</p><p>由此，我们来处理整个数据的结构如下，我们这里做个假设，代理的对象为<code>target</code>，每个字段为<code>key</code>，每个字段对应的所有副作用函数为<code>activeEffects</code>：</p><ol><li>我们知道，<code>Set</code>类型是没有键只有值的，且没有重复项，因此我们用它来保存每个<code>key</code>的对应的<code>activeEffects</code></li><li>让每个<code>key</code>和上面第一步中<code>activeEffects</code>的<code>Set</code>对应起来的数据我们使用<code>Map</code>类型来存储，因为<code>Map</code>可以让键值一一对应起来。</li><li>最后让每个<code>target</code>和它所有的<code>key</code>对应起来的数据我们使用<code>WeakMap</code>类型来存储，这里不使用<code>Map</code>类型的原因如下，(这个下面的<code>key</code>与上面的不一样，下面这里指的是<code>WeakMap</code>这个数据类型中笼统的键)： <ul><li><code>WeakMap</code>的<code>key</code>是弱引用，不会影响垃圾回收器的工作，一旦它的<code>key</code>被垃圾回收了，那么对应的<code>key: value</code>就访问不到了，因此它经常用于存储之后当<code>key</code>所引用的对象存在时（没有被垃圾回收）才有价值的信息，就如这里。当被代理的数据被垃圾回收后，它所对应的一系列关系就没有价值了。</li></ul></li></ol></details><p>综合上面设计 bucket 数据的思考，我们得到了这个保存<code>target -&gt; key -&gt; activeEffects</code>的数据结构如下：</p><table><thead><tr><th>数据类型</th><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td><code>WeakMap</code></td><td>bucket</td><td>保存<code>target</code>和它的所有<code>key</code>的关系，保存的是一个<code>Map</code>类型数据</td></tr><tr><td><code>Map</code></td><td>depsMap</td><td>保存<code>key</code>和它的所有<code>activeEffects</code>的关系，保存的是一个<code>Set</code>类型数据</td></tr><tr><td><code>Set</code></td><td>deps</td><td>保存每个<code>key</code>的所有<code>activeEffects</code>，只有所有的副作用函数</td></tr></tbody></table><details class="hint-container details"><summary>改造完的代码完整如下：</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储 target 和 key，保存的是一个 Map 类型</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当调用 effect 时，注册副作用函数</span>
  activeEffect <span class="token operator">=</span> fn
  <span class="token comment">// 执行一次副作用函数</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 没有 activeEffect，直接 return</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
    <span class="token comment">// key -&gt; effects</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
    <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
    deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 根据 target 取出 depsMap</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 根据 key 取出所有副作用函数</span>
    <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来验证下这个代码能否正确运行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
<span class="token punctuation">}</span>
<span class="token function">effect</span><span class="token punctuation">(</span>myEff<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
dataProxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// 无输出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，当我们调用奴存在的字段时，并不会有输出了。</p><p>最后我们可以对上面的代码做一下封装，将<code>get</code>中处理数据的部分封装到<code>track</code>函数中，将<code>set</code>中处理数据的部分封装到<code>trigger</code>函数中：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 取出副作用函数并执行</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_4-4-分支切换与cleanup" tabindex="-1"><a class="header-anchor" href="#_4-4-分支切换与cleanup" aria-hidden="true">#</a> 4.4 分支切换与cleanup</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.4 分支切换与cleanup<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>分支切换</code>：例如一个三元表达式<code>res.data ? true : false</code>，根据<code>res.data</code>值的不同，会执行不同的代码分支，这就是分支切换。</p><p>分支切换可能会产生遗留的副作用函数。如下面这个代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>cosnt data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">ok</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 一些代理的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> dataProxy<span class="token punctuation">.</span>ok <span class="token operator">?</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token string">&#39;not&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>dataProxy.ok</code>和<code>dataProxy.text</code>都绑定了<code>effectFn</code>，但是实际上，<code>dataProxy.text</code>由<code>dataProxy.ok</code>决定触发与否，即这里的理想情况为<code>dataProxy.text</code>的依赖集合中不应该收集这个<code>effectFn</code>，但是目前代码的实际情况却并不是如此的，即产生了遗留的副作用函数。它导致的问题为：当<code>dataProxy.ok</code>为 false 时，我们修改<code>dataProxy.text</code>的值也会触发这个<code>effectFn</code>。</p><p><strong>要解决这个问题的整体思路是：每次副作用函数执行时，我们先将它从所有与之关联的以来集合中删除，当副作用函数执行完毕后，重新建立联系，但在新的联系中不会包含遗留的副作用函数。</strong></p><p>因此我们首先需要修改注册副作用函数的<code>effect</code>函数，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个修改的主要思路是添加了<code>effectFn.deps</code>，它是一个数组，用来存储所有包含当前副作用函数的依赖集合。然后我们修改上面提取出来的<code>track</code>函数，让<code>effectFn.deps</code>能收集这些依赖集合：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token comment">// 将 deps 添加到 effectFn.deps 数组中。这里的 deps 就是我们想要的依赖集合</span>
  activeEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成<code>track</code>函数的改造后，我们就收集到了我们想要的依赖集合，它们保存在<code>effectFn.deps</code>中，因此我们就可以继续修改<code>effect</code>函数了，添加一个<code>cleanup</code>函数，用来将副作用函数从依赖集合中清除：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// cleanup 用来将副作用函数从依赖集合中清除</span>
<span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取出依赖集合</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token comment">// 将 effectFn 从这个集合中清除</span>
    deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重置 effectFn.deps 数组</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>effect</code>函数中调用<code>cleanup</code>方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// ... 其他代码</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... 其他代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在完成以上步骤后，此时运行代码会发现进入了死循环，这是因为**我们在<code>trigger</code>方法中遍历了<code>Set</code>类型，即遍历了有<code>effectFn</code>的依赖集合，但是在<code>effectFn</code>的运行时将其从这个集合中去掉了，完成后又添加了进去。**可以简单理解为如下这个代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

set<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;遍历set&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就会造成死循环。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>这个问题在语言规范中描述如下：</p><p><strong>在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。</strong></p><details class="hint-container details"><summary>解决办法如下：</summary><p>再构造一个<code>Set</code>并遍历它</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> newSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span>

newSet<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;遍历set&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里大家肯定会有点疑问，这个新的<code>Set</code>套了一个旧的<code>Set</code>，它俩数据结构都不一样，这个新的代替旧的遍历有什么用呢？其实不是啊，当我们把一个<code>Set</code>作为参数传递给另一个<code>Set</code>时，它俩的数据结构都是一样的，如下是上面<code>set</code>和<code>newSet</code>的输出：</p><div style="text-align:center;"><p><img src="/docs/assets/image-20230315152652086-335d9410.png" alt="image-20230315152652086"></p></div></details></div><p>现在我们来改造<code>trigger</code>函数解决这个死循环问题：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，这套代码就可以按照预期运行了。</p><h3 id="_4-5-嵌套的-effect-与-effect-栈" tabindex="-1"><a class="header-anchor" href="#_4-5-嵌套的-effect-与-effect-栈" aria-hidden="true">#</a> 4.5 嵌套的 effect 与 effect 栈</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.5 嵌套的 effect 与 effect 栈<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>effect</code>是可以发生嵌套的，如<code>effect(function() { effect(function() {}) })</code>。具体场景如：在 Vue 中，一个组件里面使用了另一个组件，这就会造成<code>effect</code>的嵌套，<strong>因为 Vue 的渲染函数就是在一个<code>effect</code>中执行的</strong>。所以<code>effect</code>需要设计成可嵌套的，但是目前我们实现的代码并不能支持这一功能，原因就在于<code>activeEffect</code>这个变量上。</p><p><code>activeEffect</code>这个变量是我们用来存储通过<code>effect</code>注册的副作用函数的，但是，它目前是一个全局变量，因此就导致我们每次存储的副作用函数只能有一个，当产生<code>effect</code>嵌套时，内层的副作用函数就会覆盖外层的，所以，我们需要一个栈类型的变量来存储这些要注册的副作用函数，因此，我们对<code>effect</code>和<code>activeEffect</code>的改造如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 这是一个副作用函数栈，用来存储要注册的副作用函数</span>
<span class="token keyword">let</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-6-避免无限递归循环" tabindex="-1"><a class="header-anchor" href="#_4-6-避免无限递归循环" aria-hidden="true">#</a> 4.6 避免无限递归循环</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.6 避免无限递归循环<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>这个问题简单来说就是避免<code>effect</code>函数自动的无线嵌套导致栈溢出。这种情况其实在使用时很容易遇到，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* 其他代码 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token comment">// dataProxy.count++ 相当于 dataProxy.count = dataproxy.count + 1</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在<code>effect</code>中使<code>dataProxy.count</code>自增，这就会导致我们我们读取<code>count</code>时触发<code>get</code>将副作用函数收集到栈中，然后给<code>count</code>赋值时触发<code>set</code>将副作用函数取出来执行，但是目前它本身就还在执行过程中，因此就又触发了<code>dataProxy.count++</code>，这就会无限递归下去，导致栈溢出。</p><p>这个 bug 其实不难解决，因为我们能发现这里问题的关键就在于在<code>get</code>和<code>set</code>中执行的都是同一个副作用函数，因此，我们只要在<code>set</code>中添加一个判断条件：当这个副作用函数正在执行时，就不在<code>set</code>中执行它。代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-7-调度执行" tabindex="-1"><a class="header-anchor" href="#_4-7-调度执行" aria-hidden="true">#</a> 4.7 调度执行</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.7 调度执行<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>可调度性</code>：当<code>trigger</code>方法触发时，或者说当被<code>Proxy</code>中的<code>set</code>行为被触发从而导致副作用函数执行时，我们有能力决定它执行的<strong>时机、次数和方式</strong>。这对于一个响应式系统来说是很重要的特性。</p><p>因此，我们在不改变当前代码结构的情况下，需要实现这个需求，则需要修改<code>effect</code>这个函数：给它设计一个选项参数 <em>options</em>，允许用户指定调度器。大致如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span>
	  <span class="token comment">// options</span>
	  <span class="token comment">// 调度器 scheduler 是一个函数</span>
	  <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">// ...</span>
	  <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在有了大致的修改框架后，我们就需要在<code>effect</code>函数内部将 <em>options</em> 挂载到对应的副作用函数上：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>我们这里设定 <em>options</em> 中的可能有一个方法<code>scheduler</code>，它的参数应该为副作用函数，用来帮助用户控制副作用函数的执行。</p><p>如果这个方法存在，则直接将副作用函数传递给它，否则副作用函数直接执行。</p></div><p>有了调度函数，我们在<code>trigger</code>函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，这样就可以将控制副作用函数执行的能力给到用户了：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果一个副作用函数存在调度器，则调用这个调度器，并将副作用函数作为参数传递</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在<code>trigger</code>中就添加了判断调度器<code>scheduler</code>是否存在的代码，存在则向它传递副作用函数，不存在则直接执行副作用函数。这个调度器就是用来帮用户控制副作用执行的。</p><details class="hint-container details"><summary>验证一下以上代码：</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// options</span>
  <span class="token punctuation">{</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下：</p><p><img src="data:image/png;base64,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" alt="image-20230320151302642"></p><p>没有 <em>options</em> 的如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="data:image/png;base64,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" alt="image-20230320151629236"></p></details><p>这里其实也有一个问题，比如我们这里有<code>dataProxy.count = 1</code>这个数据，我们在多次使其自增后，只想获取到它最后一次自增的结果，那么很明显我们现在的代码并不能满足这个需求。因为它会输出所有自增的结果。</p><p>那你也许会问，这有什么意义吗？其实是有的，就比如在 Vue 中，当我们连续多次修改了一个响应式数据后，它只会触发一次更新，因为它的中间过渡状态其实是我们不需要的。</p><p>我们先来看实现这个功能的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义一个任务队列</span>
<span class="token keyword">const</span> jobQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 使用 Promise.resolve() 创建一个 promise 实例</span>
<span class="token comment">// 用它将一个任务添加到微任务队列</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来标志是否正在刷新队列</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 用来刷新队列</span>
<span class="token keyword">function</span> <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果正在刷新，则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushing<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token comment">// 设置 isFlushing 为 true，表示正在刷新</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 在微任务队列中刷新 JobQueue 队列</span>
  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    jobQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结束后重置 isFlushing</span>
    isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
	下面是验证功能的代码
*/</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 每次调度时，将副作用函数添加到 jobQueue 队列中</span>
      jobQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
      <span class="token comment">// 调用 flushJob 刷新队列</span>
      <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span>
dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下：</p><div style="text-align:center;"><p><img src="data:image/png;base64,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" alt="image-20230320154555333"></p></div><div class="hint-container tip"><p class="hint-container-title">详解</p><p>上面我们定义<code>JobQueue</code>这个队列为<code>Set</code>，主要是利用<code>Set</code>的自动去重能力。</p><p>然后定义一个微任务(<code>Promise.resolve()</code>)，它用来添加任务到微任务队列。</p><p>然后定义一个用于控制队列刷新的锁(<code>isFlushing</code>)，主要是控制队列不能重复刷新。</p><p>最后就是完成刷新队列方法(<code>flushJob</code>)。</p><p>我们在使用中，如果有 <em>options</em> 这个选项，则在<code>scheduler</code>方法中先将副作用函数添加到<code>JobQueue</code>队列中，然后调用刷新队列的方法<code>flushJob</code>。</p></div><h3 id="_4-8-计算属性-computed-与-lazy" tabindex="-1"><a class="header-anchor" href="#_4-8-计算属性-computed-与-lazy" aria-hidden="true">#</a> 4.8 计算属性 computed 与 lazy</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.8 计算属性 computed 与 lazy<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>首先，我们先总结下通过上面这些小节，我们目前拥有的函数方法：</p><ol><li><code>effect</code>：用来注册副作用函数的方法，它可以传入<code>options</code>，例如使用<code>scheduler</code>控制副作用函数的执行</li><li><code>track</code>：用来追踪和收集依赖</li><li><code>trigger</code>：用来重新触发副作用函数执行</li></ol><p>有了这些方法后，我们就可以实现 Vue 中的一个很有特色的功能：计算属性<code>computed</code>。</p><p>但是，在完成这个功能之前，我们首先来完成<code>effect</code>的懒执行。当前我们的<code>effect</code>函数是会立刻执行的，但是在某些情况下，我们不希望它立即执行，我们更希望它在该执行的时候执行，这就是懒执行。在使用时，我们可以通过给<code>options</code>提供参数<code>lazy: true</code>来开启这个功能。下面我们来实现这个功能：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在添加了懒执行的代码后，我们就可以在使用<code>effect</code>方法注册副作用函数后，在想让其执行的地方调用<code>effect</code>的返回值来执行副作用函数。如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 开启懒执行功能</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，其实能手动执行副作用函数这个功能意义并不大，因为我们直接在想执行的地方调用<code>effect</code>也是一样。但是，这个功能实现的意义在于，我们能获取到副作用函数返回的值了，如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，目前它返回的是 undefined，为了实现获取返回值的功能，我们还需要对<code>effect</code>做一些修改：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 将副作用函数的执行结果保存</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
    <span class="token comment">// 返回副作用函数的执行结果</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们再执行上面获取返回值的代码即可有正确的返回结果了：</p><div style="text-align:center;"><p><img src="data:image/png;base64,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" alt="image-20230320162700317"></p></div><p>好了，目前我们终于实现了懒执行的副作用函数，也能拿到它的执行结果了。那么现在就让我们来完成<code>computed</code>吧：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noopener noreferrer">getter | MDN<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 计算属性方法</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token comment">// 在 vue3 中，computed 返回的是一个 ref 对象，要使用 .value 才能读取具体值</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证下<code>computed</code>方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注</p><p>这个时候我们已经实现了简单的计算属性功能，但是，我们知道，vue 中的计算属性是可以缓存的，但是我们这里的值并不能缓存，因为我们目前实现的<code>computed</code>是只有读取<code>.value</code>时，它才会进行计算并得到值，所以每次调用<code>.value</code>，都会进行计算，即使<code>dataProxy.text</code>的值没有变化。</p></div><p>为了解决这个问题，我们就需要在实现<code>computed</code>方法时，添加对值进行缓存的功能，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 缓存值</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，很明显，这样会有一个问题，就是<code>isRecalculate</code>这个变量外部无法读取到，导致第一次计算后它就一直是 false，会导致后续即使<code>dataProxy.text</code>的值改变了，它也不会重新计算。</p><p>那么解决这个问题的关键就在于将<code>isRecalculate</code>设置为 true 就行了，那么怎么才能更改呢？不要忘了，<code>options</code>中可是有一个<code>scheduler</code>方法的，我们只要在这里面更改就可以解决问题啦：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hi world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">注</p><p>当<code>dataProxy.text</code>变化时，触发<code>trigger</code>方法，并进入到<code>effect.options.scheduler</code>存在的分支，触发<code>computed</code>中的这个<code>scheduler</code>，将<code>isRecalculate</code>置为 true，最后我们调用<code>.value</code>时，重新计算值并将其存储。</p></div><p>现在，这个<code>computed</code>已经近乎完美，但是确实还存在一个缺陷，也就是当我们在另一个<code>effect</code>中读取计算属性的值后，我们在其他地方修改这个计算属性依赖的值时，它应该会触发副作用函数的重新执行，但其实这里并没有，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count <span class="token operator">+</span> dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 我们期望这个地方输出 2hello，但实际这里没有任何输出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要解决这个问题，我们首先观察下上面的代码，可以发现，这是一个<code>effect</code>嵌套的问题，这个计算属性内部有自己的<code>effect</code>，然后我们在外部给他又套了一层<code>effect</code>，因此对于<code>computed</code>中的<code>getter</code>来说，它只会将<code>computed</code>内部的<code>effect</code>收集为依赖，而外部嵌套的它则不会收集。</p><p>因此，要解决这个问题其实也不难。就是<strong>当读取计算属性的值时，我们手动调用<code>track</code>函数进行追踪，当计算属性依赖的响应式数据改变时，手动调用<code>trigger</code>函数进行触发响应</strong>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 方法触发响应</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 当读取 value 时，手动调用 track 函数进行追踪</span>
      <span class="token function">track</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们再来验证下上面的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count <span class="token operator">+</span> dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 2hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，它就是正确符合我们预期的了。</p><h3 id="_4-9-watch-的实现原理" tabindex="-1"><a class="header-anchor" href="#_4-9-watch-的实现原理" aria-hidden="true">#</a> 4.9 watch 的实现原理</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.9 watch 的实现原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>watch</code>本质上就是观测响应式数据，当数据变化时通知并执行相应的回调函数。</p><p>格式如下：<code>watch(obj, () =&gt; {/* 其他代码 */})</code>，obj 是观测的响应式数据，回调函数是当数据变化时执行的。</p><p><strong>实际上，<code>watch</code>的实现本质上就是利用了<code>effect</code>以及<code>options.scheduler</code>选项</strong>。如下代码所示是一个简单的<code>watch</code>的实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们能很容易的看出来，这是个代码是有问题的，因为上面我们硬编码观测的是<code>dataProxy.count</code>，所以，首先我们先解决传入的问题是一个对象，如<code>dataProxy</code>时，我们需要递归读取它上面的属性，从而当任意属性发生变化时都能触发回调函数执行，这个递归的方法我们将其命名为<code>traverse</code>，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归方法，用来读取 watch 中传入的对象的属性</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// seen 用来保存已经读取过的属性</span>
  <span class="token comment">// 如果传入的数据是原始数据类型，或者已经被读取过了，则什么都不做</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 将读取了的属性存储到 seen 中，避免循环引用</span>
  seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token comment">// 暂时不考虑数组等其他结构</span>
  <span class="token comment">// 假设 value 是一个对象，使用 for...in 读取对象的每一个值，并递归调用 traverse 方法</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> seen<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>目前，我们实现了非硬编码观测对象的能力，但是，我们知道，<code>watch</code>不仅能传入一个对象，也能传入一个<code>getter</code>函数，如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;dataProxy.count改变了&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>因此，<code>watch</code>函数修改如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>ok，目前，我们也完成了传递<code>getter</code>函数的功能，现在，还有一个功能我们没有完成，也就是<code>watch</code>中获取到被观测数据改变前后的值，即<code>oldValue</code>和<code>newValue</code>。</p><p>现在我们来完成这个功能：</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
        newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
        <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
        oldValue <span class="token operator">=</span> newValue
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
  <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
  oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了 2 1</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是这个<code>watch</code>方法的基本实现了。</p><h3 id="_4-10-立即执行的-watch-与回调执行时机" tabindex="-1"><a class="header-anchor" href="#_4-10-立即执行的-watch-与回调执行时机" aria-hidden="true">#</a> 4.10 立即执行的 watch 与回调执行时机</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.10 立即执行的 watch 与回调执行时机<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>上节我们完成了<code>watch</code>方法的基本实现，其本质就是对<code>effect</code>的二次封装。本节我们继续完成<code>watch</code>的两个特性：</p><ol><li>立即执行的回调函数</li><li>回调函数的执行时机</li></ol><p>默认情况下，<code>watch</code>方法的回调函数只在被观测的数据变化时才会触发，但是，在 vue 中，<code>watch</code>可以通过传入<code>immediate</code>参数来指定回调是否需要立即执行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;变化了&quot;</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了完成这个功能，我们需要改造<code>watch</code>函数，在其中添加<code>options.immediate</code>的判断：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token literal-property property">scheduler</span><span class="token operator">:</span> job
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">oldValue<span class="token punctuation">,</span> newValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span> <span class="token comment">// 响应式数据改变了 1 undefined</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，我们就完成了回调函数立即执行的功能。</p><p>现在，我们就来完成执行回调函数执行时机的功能，同样的，我们也需要使用一个<code>options</code>参数来实现，在 vue 中，这个参数是<code>flush</code>，它有三个值：<code>pre | post | sync</code>。</p><p>要实现控制执行时机，其实我们在<a aria-current="page" href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-7-%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C" class="router-link-active router-link-exact-active">4.7 调度执行</a>中提到过，使用<code>Promise.resolve()</code>方法，将要执行的方法添加到微队列中即可。实现如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上述代码，我们实现了<code>flush === &#39;post&#39;</code>的情况，而剩下的<code>sync</code>就是同步执行，至于<code>pre</code>，它涉及到组件的更新时机，目前没办法模拟。</p><h3 id="_4-11-过期的副作用" tabindex="-1"><a class="header-anchor" href="#_4-11-过期的副作用" aria-hidden="true">#</a> 4.11 过期的副作用</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?" target="_blank" rel="noopener noreferrer">4.11 过期的副作用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>举个例子，我们发送了一次网络请求，那么在这一次请求的结果还没有返回时，我们又重新发送了一次请求，那么，前一次的请求就是过期的。拿副作用函数来说就是前一次的副作用函数还没有执行完成时，有了新的副作用函数执行，那么前一次的就是过期的副作用。</p><p>因此我们就需要一个让副作用过期的手段，不执行过期的副作用。在 vue 中，<code>watch</code>的回调函数接收第三个参数<code>onInvalidate</code>，这个参数是一个函数，类似于事件监听器，我们可以使用<code>onInvalidate</code>注册一个回调，这个回调函数会在当前副作用函数过期时执行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表未过期</span>
  <span class="token keyword">let</span> expired <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// 调用 onInvalidate() 函数注册一个过期的回调</span>
  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当过期时，将 expired 置为 true</span>
    expired <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token comment">// 网络请求</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;url&#39;</span><span class="token punctuation">)</span>
  <span class="token comment">// 当该副作用函数的执行还没有过期时，才会执行后续操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如上面的代码，我们在发送请求前就先定义一个变量<code>expired</code>来标识这次的副作用函数的执行是否过期，然后使用<code>onInvalidate</code>函数注册一个过期时的回调，用来改变<code>expired</code>的值。然后再发送请求，并判断是否过期，未过期则执行其他后续操作。</p></blockquote><p>下面，我们来改造<code>watch</code>函数，给它的回调函数添加<code>onInvalidate</code>函数参数。这个函数的<strong>原理就是在<code>watch</code>内部每次检测到变更后，在副作用函数重新执行之前，会先调用通过<code>onInvalidate</code>注册的过期时的回调函数</strong>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 定义 cleanup 变量用来存储用户注册的过期回调函数，这跟我们在外面定义的 cleanup 全局方法不一样</span>
  <span class="token keyword">let</span> cleanup
  <span class="token comment">// 定义 onInvalidate 函数</span>
  <span class="token keyword">function</span> <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将过期的回调存储到 cleanup 中</span>
    cleanup <span class="token operator">=</span> fn
  <span class="token punctuation">}</span>

  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用回调函数前，清除过期回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cleanup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数，将 onInvalidate 作为第三个参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注</p><p>上面定义了一个变量<code>cleanup</code>，它与上面我们用来将副作用函数从依赖集合中清除的<code>cleanup()</code>方法不同，这里它用来保存我们通过<code>onInvalidate</code>函数注册的副作用过期时的回调。</p></div><h3 id="第四章的完整代码" tabindex="-1"><a class="header-anchor" href="#第四章的完整代码" aria-hidden="true">#</a> 第四章的完整代码</h3><details class="hint-container details"><summary>完整代码</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储 target 和 key，保存的是一个 Map 类型</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// cleanup 用来将副作用函数从依赖集合中清除</span>
<span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取出依赖集合</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token comment">// 将 effectFn 从这个集合中清除</span>
    deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重置 effectFn.deps 数组</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 这是一个副作用函数栈，用来存储要注册的副作用函数</span>
<span class="token keyword">let</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 将副作用函数的执行结果保存</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
    <span class="token comment">// 返回副作用函数的执行结果</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>

<span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token comment">// 将 deps 添加到 effectFn.deps 数组中。这里的 deps 就是我们想要的依赖集合</span>
  activeEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果一个副作用函数存在调度器，则调用这个调度器，并将副作用函数作为参数传递</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 定义一个任务队列</span>
<span class="token keyword">const</span> jobQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 使用 Promise.resolve() 创建一个 promise 实例</span>
<span class="token comment">// 用它将一个任务添加到微任务队列</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来标志是否正在刷新队列</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 用来刷新队列</span>
<span class="token keyword">function</span> <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果正在刷新，则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushing<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token comment">// 设置 isFlushing 为 true，表示正在刷新</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 在微任务队列中刷新 JobQueue 队列</span>
  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    jobQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结束后重置 isFlushing</span>
    isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 计算属性方法</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 方法触发响应</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 当读取 value 时，手动调用 track 函数进行追踪</span>
      <span class="token function">track</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>

<span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 定义 cleanup 变量用来存储用户注册的过期回调函数，这跟我们在外面定义的 cleanup 全局方法不一样</span>
  <span class="token keyword">let</span> cleanup
  <span class="token comment">// 定义 onInvalidate 函数</span>
  <span class="token keyword">function</span> <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将过期的回调存储到 cleanup 中</span>
    cleanup <span class="token operator">=</span> fn
  <span class="token punctuation">}</span>

  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用回调函数前，清除过期回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cleanup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数，将 onInvalidate 作为第三个参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归方法，用来读取 watch 中传入的对象的属性</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// seen 用来保存已经读取过的属性</span>
  <span class="token comment">// 如果传入的数据是原始数据类型，或者已经被读取过了，则什么都不做</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 将读取了的属性存储到 seen 中，避免循环引用</span>
  seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token comment">// 暂时不考虑数组等其他结构</span>
  <span class="token comment">// 假设 value 是一个对象，使用 for...in 读取对象的每一个值，并递归调用 traverse 方法</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> seen<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="第五章-非原始值的响应式方案" tabindex="-1"><a class="header-anchor" href="#第五章-非原始值的响应式方案" aria-hidden="true">#</a> 第五章 非原始值的响应式方案</h2><p>通过上一章我们了解到了响应系统的概念与实现，并简单介绍了响应式数据的基本原理。</p><p>这一章我们就专注与响应式数据本身，深入探讨实现响应式数据都需要考虑哪些内容，其中的难点又是什么。</p><p>实际上实现响应式数据是很难的，并不是简单的<code>get/set</code>操作即可，还有例如拦截<code>for...in</code>循环，代理<code>Map | Set | WeakMap | WeakSet</code>等数据类型。</p><h3 id="_5-1-理解-proxy-和-reflect" tabindex="-1"><a class="header-anchor" href="#_5-1-理解-proxy-和-reflect" aria-hidden="true">#</a> 5.1 理解 Proxy 和 Reflect</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3" target="_blank" rel="noopener noreferrer">5.1 理解 Proxy 和 Reflect<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><code>Proxy</code>可以创建一个代理对象，它能够实现对其他对象的代理，但是也 <strong>只能代理对象，无法代理如<code>string | boolean | number</code></strong> 等原始值。</p><p>代理：指的是对一个对象基本语义（或者说基本操作，如读取、赋值）的代理，它允许我们拦截并重新定义对一个对象的基本操作。</p><p><code>Reflect</code>是一个全局对象，其有许多方法。任何在<code>Proxy</code>的拦截器中能够找到的方法，都能够在<code>Reflect</code>中找到同名函数。</p><p><a href="http://localhost:8080/docs/ts/Proxy%E5%92%8CReflect.html" target="_blank" rel="noopener noreferrer">Proxy 和 Reflect<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_5-2-javascript-对象及-proxy-的工作原理" tabindex="-1"><a class="header-anchor" href="#_5-2-javascript-对象及-proxy-的工作原理" aria-hidden="true">#</a> 5.2 JavaScript 对象及 Proxy 的工作原理</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3?" target="_blank" rel="noopener noreferrer">5.2 JavaScript 对象及 Proxy 的工作原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>这一节主要讲解了 <strong>ECMAScript 规范</strong> 中 JavaScript 中的两种对象：</p><ol><li>常规对象：满足以下三点要求的对象就是常规对象。 <ul><li>必须使用 ECMA 规范10.1.x给出的定义实现</li><li>对于内部方法<code>[[Call]]</code>，必须使用 ECMA 规范10.2.1给出的定义实现</li><li>对于内部方法<code>[[Construct]]</code>，必须使用 ECMA 规范10.2.2给出的定义实现</li></ul></li><li>异质对象：所有不属于常规对象的对象都是异质对象。</li></ol><p>区分函数对象和普通对象：通过内部方法和内部槽来区分。函数对象会部署内部方法<code>[[Call]]</code>，而普通对象不会。</p><p>Proxy 对象内部的方法<code>[[Get]]</code>没有使用 ECMA 规范的10.1.8给出的定义实现，所以 Proxy 是一个异质对象。</p><p><strong>内部方法的多态性</strong>：不同对象有同样的内部方法，但是这些内部方法的实现方式又有不同。</p><p>创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来自定义被代理对象的内部方法和行为的。即我们代理了一个对象<code>obj</code>，代理对象就是<code>objProxy</code>，被代理对象就是<code>obj</code>，我们指定的拦截函数是给<code>objProxy</code>的，而<code>obj</code>其实没什么变化。</p><h3 id="_5-3-如何代理-object" tabindex="-1"><a class="header-anchor" href="#_5-3-如何代理-object" aria-hidden="true">#</a> 5.3 如何代理 Object</h3><p><a href="https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3?" target="_blank" rel="noopener noreferrer">5.3 如何代理 Object<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>下面是一些对普通对象的所有可能的读取操作：</p><ol><li>访问属性：obj.foo</li><li>判断对象或原型上是否存在给定的 key：key in obj</li><li>使用 for...in 遍历对象：for (const key in obj) {}</li></ol><p>下面就逐步讨论如何拦截上面这些读取操作。首先是属性的读取，我们知道可以使用<code>get</code>来进行拦截。</p><p>但是<code>in</code>操作符呢？<a href="/docs/ts/Proxy%E5%92%8CReflect.html" class="">Proxy 中拦截各种情况的函数</a></p><blockquote><p><code>in</code>操作符的运算结果是通过调用一个叫做<code>HasProperty</code>的抽象方法得到的。关于这个抽象方法，可以在 ECMA-262 规范的 7.3.11 中找到。</p><p><code>HasProperty</code>抽象方法的返回值是通过调用对象内部的<code>[[HasProperty]]</code>得到的。这个内部方法对应的拦截函数为<code>has</code>。</p></blockquote><p><strong>因此我们可以通过<code>has</code>拦截函数实现对<code>in</code>操作符的代理。</strong> 如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token string">&#39;foo&#39;</span> <span class="token keyword">in</span> p <span class="token comment">// 会建立依赖关系</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面我们知晓了<code>in</code>操作符的拦截，那么<code>for...in</code>呢。</p><p>通过上面那个链接，我们能直接得到答案，使用<code>ownKeys</code>方法即可拦截<code>for...in</code>操作。至于原因，如下：</p><details class="hint-container details"><summary>详情</summary><p><img src="/docs/assets/image-20230424152041585-1ae033e2.png" alt="image-20230424152041584"></p></details><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">ITERATE_KEY</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将副作用函数与 ITERATE_KEY 关联</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">为什么使用 ITERATE_KEY 作为追踪的 key</p><p>因为<code>ownKeys</code>拦截函数与<code>get/set</code>不同，在<code>get/set</code>中，我们可以得到具体操作的 key，但是在<code>ownKeys</code>中，我们只能拿到目标对象的 target。</p><p>这里追踪的是 ITERATE_KEY，那么在触发响应时也应该用它：<code>trigger(target, ITERATE_KEY)</code></p></div><h2 id="第六章-原始值的响应式方案" tabindex="-1"><a class="header-anchor" href="#第六章-原始值的响应式方案" aria-hidden="true">#</a> 第六章 原始值的响应式方案</h2></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><!----></div></footer><nav class="page-nav"><a href="/docs/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A7%88.html" class="nav-link prev" aria-label="第一篇 框架设计概览"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第一篇 框架设计概览</div></a><!----></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-0ea0852b.js" defer></script>
  </body>
</html>
