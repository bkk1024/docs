import{_ as a,W as d,X as l,Y as o,Z as e,$ as c,a1 as i,a0 as r,C as n}from"./framework-4f54a744.js";const p="/docs/assets/image-20230309164152969-3acdb7f0.png",k={},b=o("h1",{id:"websocket",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#websocket","aria-hidden":"true"},"#"),e(" WebSocket")],-1),h=o("code",null,"HTML5",-1),u=o("code",null,"WebSocket",-1),m=o("code",null,"WebSocket",-1),_=o("code",null,"ws | wss",-1),g=o("code",null,"wss",-1),S={href:"https://baike.baidu.com/item/TLS/2979545",target:"_blank",rel:"noopener noreferrer"},w=o("code",null,"WebSocket",-1),W=r('<blockquote><p>ws://echo.websocket.org</p><p>wss://echo.websocket.org</p></blockquote><p><code>WebSocket</code>与<code>HTTP</code>和<code>HTTPS</code>使用相同的<code>TCP</code>端口，可以绕过大多数防火墙的限制。</p><p>默认情况下：</p><ul><li><code>WebSocket</code>使用 80 端口</li><li>如果运行在<code>TLS</code>上，则默认使用 443 端口</li></ul><h2 id="websocket简介" tabindex="-1"><a class="header-anchor" href="#websocket简介" aria-hidden="true">#</a> WebSocket简介</h2><p><code>WebSocket</code>允许<strong>服务端主动向客户端发送信息</strong>。在<code>WebSocket API</code>中，客户端与服务端只需要完成一次握手，两者之间就能创建持久性的连接，并进行双向数据传输。</p><p>下图表明轮询与<code>WebSocket</code>的区别：</p><p><img src="'+p+`" alt="image-20230309164152969"></p><h2 id="websocket优点" tabindex="-1"><a class="header-anchor" href="#websocket优点" aria-hidden="true">#</a> WebSocket优点</h2><p>一般来说，<code>WebSocket</code>有以下几个优点：</p><ol><li>较少的开销控制：在创建连接后，客户端与服务端之间交换数据时，用于协议控制的数据包头部相对较小</li><li>更强的实时性：由于客户端和服务端是双端联通的，所以服务端可以随时给客户端发送消息，相较于服务端被动等待客户端请求的方式，明显延迟更低</li><li>保持连接状态：与<code>HTTP</code>不同的是，<code>WebSocket</code>需要先创建链接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息</li><li>更好的二进制支持：<code>WebSocket</code>定义了二进制帧，相对于<code>HTTP</code>可以更轻松的处理二进制内容</li><li>可以支持扩展：<code>WebSocket</code>定义了扩展，用户可以扩展协议、实现部分自定义的子协议</li></ol><p>因为以上的一些优点，因此它被广泛应用于即时通讯/IM、实时音视频、在线教育和游戏等领域。</p><h2 id="websocket-api-学习" tabindex="-1"><a class="header-anchor" href="#websocket-api-学习" aria-hidden="true">#</a> WebSocket API 学习</h2><p>首先，关于<code>WebSocket</code>的兼容性，我们可以到这个网站进行查阅：https://caniuse.com/</p><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h3><p>我们可以使用<code>new</code>来创建一个<code>websocket</code>实例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span> <span class="token parameter">url</span> 表示连接的 url
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string <span class="token operator">|</span> Array<span class="token punctuation">&lt;</span>string<span class="token punctuation">&gt;</span><span class="token punctuation">}</span></span> <span class="token parameter">protocols</span> 可选，一个协议字符串或包含协议字符串的数组
 */</span>
<span class="token keyword">const</span> websocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> protocols<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">注</p><p><code>protocols</code>这些字符串用于指定子协议，这样单个服务器可以实现多个<code>WebSocket</code>子协议。</p><p>如你可能希望一台服务器能够根据指定的协议处理不同类型的交互。如果不指定协议字符串，则假定为空字符串。</p><p>使用<code>WebSocket</code>构造函数时，当尝试连接的端口被阻止时，会抛出<code>SECURITY_ERR</code>异常。</p></div><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h3><p><code>websocket</code>对象包含以下属性，每个属性具体含义如下：</p><ul><li><code>binaryType</code>：使用二进制的数据类型连接；</li><li><code>bufferedAmount</code>（只读）：未发送至服务器的字节数；</li><li><code>extensions</code>（只读）：服务器选择的扩展；</li><li><code>onclose</code>：用于指定连接关闭后的回调函数；</li><li><code>onerror</code>：用于指定连接失败后的回调函数；</li><li><code>onmessage</code>：用于指定当从服务器接受到信息时的回调函数；</li><li><code>onopen</code>：用于指定连接成功后的回调函数；</li><li><code>protocol</code>（只读）：用于返回服务器端选中的子协议的名字；</li><li><code>readyState</code>（只读）：返回当前 WebSocket 的连接状态，共有 4 种状态： <ul><li><em><strong>CONNECTING</strong> — 正在连接中，对应的值为 0</em></li><li><em><strong>OPEN</strong> — 已经连接并且可以通讯，对应的值为 1</em></li><li><em><strong>CLOSING</strong> — 连接正在关闭，对应的值为 2</em></li><li><em><strong>CLOSED</strong> — 连接已关闭或者没有连接成功，对应的值为 3</em></li></ul></li><li><code>url</code>（只读）：返回值为当构造函数创建 WebSocket 实例对象时 URL 的绝对路径。</li></ul><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h3><p><code>websocket</code>主要方法有两个：</p><ol><li><code>send(data)</code>：该方法将需要通过<code>websocket</code>传输的数据排入队列，并根据所需要传输的数据的大小来增加<em><strong>bufferedAmount</strong></em>的值。若数据无法传输（如数据需要缓存而缓冲区已满）时，套接字会自动关闭。</li><li><code>close(code, reason)</code>：该方法用于关闭<code>websocket</code>连接，如果连接已经关闭，此方法不会执行任何操作。</li></ol><h3 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h3><p>使用<code>addEventListener()</code>或将一个事件监听器赋值给<code>websocket</code>对象的<code>oneventname</code>属性，来监听下面的事件。</p><ul><li><code>close</code>：当一个<code>websocket</code>连接被关闭时触发，也可以通过<strong>onclose</strong>属性来设置；</li><li><code>error</code>：当一个<code>websocket</code>连接因错误而关闭时触发，也可以通过<strong>onerror</strong>属性来设置；</li><li><code>message</code>：当通过<code>websocket</code>收到数据时触发，也可以通过<strong>onmessage</strong>属性来设置；</li><li><code>open</code>：当一个<code>websocket</code>连接成功时触发，也可以通过<strong>onopen</strong>属性来设置。</li></ul>`,27),f={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket",target:"_blank",rel:"noopener noreferrer"};function v(x,T){const t=n("RouterLink"),s=n("ExternalLinkIcon");return d(),l("div",null,[b,o("p",null,[e("为了解决"),c(t,{to:"/js/%E8%BD%AE%E8%AF%A2.html"},{default:i(()=>[e("轮询")]),_:1}),e("带来的一些问题，"),h,e("定义了"),u,e("协议，它能更好的节省服务器资源和带宽，并且能够更实时的进行通讯。")]),o("p",null,[m,e("使用"),_,e("的统一资源标志符（URI），其中"),g,e("使用了"),o("a",S,[e("TLS"),c(s)]),e("的"),w,e("。如：")]),W,o("p",null,[o("a",f,[e("WebSocket 接口参考 | MDN"),c(s)])])])}const L=a(k,[["render",v],["__file","WebSocket.html.vue"]]);export{L as default};
