import{_ as i,W as l,X as u,Y as n,Z as s,$ as a,a1 as c,a0 as e,C as o}from"./framework-4f54a744.js";const d="/docs/assets/image-20230314224201381-b6f3e1f3.png",r="/docs/assets/image-20230315152652086-335d9410.png",k="data:image/png;base64,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",v="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAABUCAIAAACeF/fRAAALyklEQVR4nO1cf2wT1x3/NPhYj+wcLkec68XY8a5ujQkO1NCSBTOSUWfColSV14FGWVk3mEALaJRR6FR13VYqsVWUAQKq/hClgnV0CutSiVSrJzLmqCklCdR1ca/5Mce1ExwnvsKxnJvtDyfETmxj49BOtT9/xe+9+773yffde8/fz/v6Nv5uE3IPBV/1AL4a5GnnEvK0cwmKxMVF1vpdNpVw8ukjzZEseyiy1u+ycaP/Xqnv7NF9Da4ENk3rnnzETEX/Hgm7/7r31bPBLHtOgSTeVrFUARSsTpt9D1eDA0OSJEkRGQCpqrbbuETNBoIhUZIkKTICFCgNtjVV2XedHEm8PYWQzx179hwAEMbVOzfOpwiyMFEzb+PBZxoBgLHWb7NxhOL2WzmoL/Hdll2BUBrNgp191275WNLwNqHUmMwGKiy0u4SQlKxNiaFyAQff+XZ3Xzjb5SAdkAx3p7HiZnu8AW160bpfrDSrSACotUHyN/9p30m3HNuEKFn64w02IxWdN8vtEF2NR15u9ssJzE0NCI1t6/plahLjPZ46cNiZyQqYcpJTZvvDZhUpRyRJGpYBkKzlB6vjzvB0zeYtK41UAcRejyB4fCJAGW0/31hFZEomXVBLN29YpiYBqc8rCF5RBijjqs3rDJn0eANvR3odrxxuECQAhOahnZuqGFIzl0eHEK0mLPb7dQqE244+e+JCdP4zNVt21qn1S21qZ4P3pnilhmlVrU4Bueft3QcdQQAgWFv9TgtrXvXAu+430+0xpbdlT+OBKGcAcs9bLT4AM0s1Y/WKJWaegORqPHnh+jsfdLzTIQK01nhLNgl+rrYQEDtOO8bmtOxv/HuHBND6xQl3xoRIObbApdbYN1Tu7BPBUeMF2lIGQOQb6to623jpdCUAFLFaQEh7HOlCU0oBCPnjLH/47xBMpJLVAr70zKSkPYLUK6RqphIAxVtq+Ul1X9y6JQ3iQPxklhEBkMlWn9VM7BsMA8o+5/4TLRM3NlkM9GdjOiWoYjXgGv9MQAFAjqS/32dFuzsQBJRUIenzedJ+SFmsBm7cnCnVJ2rWExCho2iWj32D5s6mAYT93WkPIqtTWuQDjw8gTd9fex87/v8j9dbHtq+tZia37wmEAXAmK53Kqqf3MgAlf2+iRVFo/jgEUKa6mjH7hG7V90wkEHK3pPliI9sz+VDja2/rt63QVdh3Pr3c2x2UcHux9g5GUYAI9Jj0FUr4V3tokYVW2+qfqPQNQqVTS2f2PN84cddxnvfU6fTU/I07Sjx9/y3muBndJ594tTVa6W1weOY/pNeseOq3Vd7uAag0aooABs+dmmQnBZJ4eyTxghT5AkDcOhdyHDhy2iPKUMxU87yeL2MUkHznjv/hpZYEz3tPHf+HVwJIRs3zaqpAviaGE/TiPN7QEQRAlel5NUMWyJ8PxtYefuEtlzgCBa3meTVFAKLr1KGj7kzW0NuSRE4JyjCnrPcjtxhnTMEaDYrOi97JJ3OS5tTau9jIJU93v19MPQKS4e408tP97ktd/cmbKihWe9cc1bDH/Yk3wVcBQlmi0RtUsiB09WV+Jk9G+2uOHA0q5WnnEvK0cwl52rmEPO1cQp52LuHWi0FpIgvpj1q+/cm6Uvcbj499Ob0x/m+8nYX0p5qlBIgZ38ygt/8bb39tpb808aVIf0loE2xFlalkkrxCqs1VJnbyDFFQLG+usS4z8zSZ0FyJycyP1pA0b7bUWSpUyixmGkGpTFV1lorE3d0YSbpesnrtCp04e//v3ogNXuptP1q3cGanYvve5vFCZuEjm+2m0YBeYnmQt294ZDHVqfzV34o2/aSGiw51uR2hllf3HM8oGAQAzOK1G9dU0KNGJK/D+XnGgluqSU7NUscXsHQhIIliTBH/8Fa7iQFksdcjeP3SCEjWsnZTfGy0gAAAlWXbxhqOhNTnFbxBCQC9eNUDE7q4IRjbo2OcR+QIQKprag0Z+zyJtwMDInTUNAIACGUJjVBfOAKSIIBr8jjtIpttkRIIt73yzAmXDADk4kd3rDGorfZqx4tn4/1YyNDD/veP7o0KZlTN1h0rdDRnBDJRCE0PLmQBhNte33OyLRwBWfHDXWvnKzPijKTeHrwaAaBkeKBq/VPbtu9abRoTH2L1p0o9B6Cn+aRrjKHU8marHyC0cxdPMhpue/3310VC8QNPHxC5miBymgKGeeUkIHX8+URbNGwoXXx9b7M/IxtAUm/7wiJATyMAM68mAEJr1ENiKcSJWzzHABD7O2MDl2Jnr7iMpYpLuQlCnP9coyvG/0ON+7Y3ZjrcO4qVgOz7pCOmLOjuDVvYzBye7N32DogAVcxxujISAKjyyqiMOlF2A8TLXXGfo9Smz5j4wg1fFTElkMTL2ZpIRluOKgEKo45GUPCEwegX6IspIHJtYsyamlUe9zm6rA5fTXLNJXsQioR3nTJBMtqeYBgA++37SiH1tr7XJYGtMCkBiEPj3hZ8QQBUiS72VaF0ZRQQGQikr0glAlOqT1D62UAYIMv4uPVfpcx4JU+6gYWGJICkZhIR76W2tk/7AZphACkce8nKeU6QAY3FbhzbORnL6kUsIHdfSCQGpYVU0p/700AEoO+xX1f+FMZ1tfqM9+2kJyXxmgyQAHyeFoDs9j+oYQHIkSsxjeTmxvdq6quZ+et3390X8A0rOI4lCxDpaTrpvHlZP5X05zzjrtNXFOrqfvncAp9XvK1UW3Yzp72k3hY6vREA8Hd/LAPh85f8ACAHuuPXL1/DnmMtfgkEqVLzapYsgORvPnaoKe7iXVRITPt+Q0rpr+PEyw6fBBSQKrWeL1NK7oYXz/gB4Is0zQMpNTCCMszRBjwXR3U3kp6nL+2aKAaOYkzNEz71+hLpdJRhjqq7Q8hklUsp/ZE0p9ZqlaLbJYQkEEqDobT7gid983npL5eQp51LyNPOJeRp5xLytHMJedq5hDztXEKedi5hWvGs0lT1JMPNWVi1QEuKgwNX/jMysVY/v3LG0GcTL/iSvGVRcb83NPHer4JijebvzJ9NhocGrg5PNAaQvNmouBy4OgIQypK59y4xlmBoMHRt6rMIU0VX4pLrgMnJdZZNL9h0svCXx190xj5n3fSsTTPiObVj/3gxwVrWbbYZxoP4orvhyFFHf2yoZunW51bqxNb9BzuXbrCb6LGJKHU27jvYlE56aPpIOsnTSa4TAkGA0FZaYoN4iiVGDYDPOi+OlzE1P3vcZlBiJOwTPILgFUdAGR7csj7uQUwDAFK/pv5hE10gi70eoTcMgNRZ7dVTnESYLOqYVnKdz+kKLbbQmspFRPNYpFRZW6kD0NPedF0DUVSv+a6GwOC5Y88fvTiaG2it32bj9DU2rvlUfDxdMZNRXPE0HjoczRLlV//mp2alanZ5Omk16SOJt9NMrvM1ne8FiPKKe8e8UWQxlAGy5/w/r09fwnKPXgHJ3XT84nhuYFPTh2GA0RonuXG48/Qf91/PjBVcXRIgXZliiSWJt9NNrgs7L3lry9T8PTWKs00RgKo2ckCkpz0mXbC8lAYgE2VWa/G4MaIQGBWS4twofdzsiL2i1PHSr7ffNLukSBVaTye5TnynvadGrdEYLUSTQ1YunaMG5O722F90YKlCAEq+2jo5NxCTlvPIcGbS780hFe20kutkx3nBquF18+5XOtqsFSwgfdQau7DDL14BKL/z0GutE6dqROzPXJueCiShnUFynexs77Lxeu4uCz/dSAOSp7UtrkFXIARQRVSh1zf1qa43iSRLWkbJdc4z7itAWc36KgaQhPaO+Gr5fcELkBUrH1vIji9gJG97dMtjVQlyA78MJJvkGSXXdbQJUoWJVBQAofZ3OyZWi2+/fJrfWacx2bftruvt6rsGsricowlAxreQ0Y8LTBWSHlcySq676Hg/eooKuZoTydpBx6EDp4VwBARVpud5PUcTkLxtb+yOuyUa1e4mn1lvAW6kgaWdXEfSJl7dK1wIptphSYbjyvmk1khunk52u/pvYer3KPLSXy4hR2n/Dzha6XI/Q66gAAAAAElFTkSuQmCC",m="data:image/png;base64,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",b="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJMAAAAsCAIAAADuGx3iAAAKO0lEQVR4nO2af2wb5RnHv7h3aS7tXeO4cZzLYce7HoTUmKxpt2QsoelKgrBKEGS0CKj4pVaikMJY1x/bKkSBTarYujIqqBigdlpb1EkpyN3oGJkSQSL1ByW4xtS1Eqeu67jYTnxpLuSObH84TezYTn3tyurJH+WP+Hmf932ee7/ve+97790N/M1WTPGLyt/a5uO861erggrSUKq5eXle/95RKcGq4R4pQPewz51gpWrytHMBjEc+UiSAWJRvKh3z2McvU8s2l8eIY9JNyLPUwLN3LJOIl2Xuyrll7uGvTiQYiUUFFcKo68D4tKumavL4mgI4hj0fKfKvK19aPn/4xLGXnhtJ1/hP9tffWTpyYtex9w6oywpA6Vz2e5L/k28TjAWz2MVU+NjwaFLIG1Ipl4By5sCnb+1SnUeWo9HWQ+xIEHLB7xc/uagg1N29fePYpJHdZn26vlCTUPcKlVMJkfizI+i5g2HJeNNoOHStk7juYLdZWuuZyCnHu9sGB84DALFc37SwABj2dIzFewa90aFvCvLjTXK4X+Vt4IqYNudyAACIlez6JxYUzwagSN+MA5rZswkNMHTi2PbnRtKuI98ps4rml/yvc7j+GD8ldrlDs8vnzNdRBcQsktAow9EzHZ+/tUUau3zt74bcnMtWNJd3yXFdklMuW8kpl63klMtWcsplKznlspWcctlK3OnXvMbWLTa95+ALuzuv9pRgXmPrFhs7MSqk4Cd7drY5U7RpXf3LR6rp2P/jUdf7O9795P/vpI1pWL+tiZv4IQU6D+w86JIzrGtdtfWJKql95/Y2f1JZ3JzTG2gNCIPZdNXJYiQUHpIkSVJkAJT+9hYbm8otHIqIkiRJyjigYSpsD9ZefejrDikSDkmSJI3JAChDXbONu2ydSxiKaIBiqFRlRCrjVSMf//MrxwGArFy1eW0VTVJzUrn57LtetAOArrH1eRtLEvmpvLIc+eTeF08CAFnx0NZHqxgiP6UQqrnG65zsHIhk4BbqDY5e20SuA2SX/7+5FqRRjmSM1Q2NS6t5bfoBQjLFt9Y1NtVZ9My1mblJUDr2qiNSfF0tn3RRJFNRW5dsBigta61tstXeaqDJ5FKAEqqshlgyBG2w1NrqqoUZ+iyD/HR8dUNdtTl1uDhS9IB2yeqfrajWUwCwzJZyUSWL6x9fY6ukY7ovb4HotO9+uzOQ6cqrHtJoe/axpdxEnyxvgeg89PqbXaoHsdD8UEsVXU1s2NEZb659/NEVZvHGwMvvTb1aI4z3PvVkAzsRsrE51R6q7rGnbebosTd29P1oXYtVF/O0Qeo/vH1Xu9rkEq7R9kDI8Tf3DMtH0pyjq1seqNZTshK3qK5clfA+Qduwbv2KSloD8Zzb43H7RYCutD2ztvZyw+SKoevXrVnKUYAU9Hk8PlEG6MrmdasrrjCiroRP+M0WMQCkiwNTpnkNa9Y2sBQgBfwet39QhoapuPfZVZUJIYlZAKibV25oseogR/2x3gBlvPNBtb1BVK2elE2RAY3OYqvRz+CfbFLOtb/zZptHAkAa79v8VK2OMi7k0eOJFZN1LXeaCURP7nll/xexL0N0Des3N3FCvY3ravOpyzcjrM3LzATk/sO/mRjIpMHWurnOUN18z8euv6qK2DcwBNAgNABAabn8UV9EApVPAhgdiU76We5pMuZB6be/+tqRCACQxSt+/ny9oerelg7nvsQ9OklrScndtuud9gsyAGHV1qer6BJTObpUvBtnli21UoDSf2TXW3a/BMLQuOYZmzEvbYWkOSe77a/HZAMg93/Q7QdQWGK8VE78uJonITntB7+Y/KAn1P6PHhHQmiqvyYLHLzTNAcSeDyfvP3LA/s8eCdAKNSkfN9Ijj0oywBSVAmxL65YNG9faaICcBSAanhoDQoWRAqKOvx+5tMGSL3xwxCEBWmFJUkil375zd0w2AG5HrwSMiBfV5EXWVJQB8HXssfslAFACR3a3OaX0NZK6euD00fjVSu4NimDpKYOpRAdAmc0ta7JNWfMYAJhnMAEeNQlnhLGEBhAJJLR86mwEVooxmIDkp9QZCEYlgMQs0N8XtADKhMUkUMQAUWXykzSY9YUAQgMJk6bnXAgWjtFPDym5Oo/E76AdezdtUpMSAJQbaAChXsfQlE052nvhgUpjmhpJyo1j5gMUfSEDgObrlvFJZd9eux0KxHDiXVGGAkD9I6D36yjAaIsFS2FsQ8EtWIwzABAKTRt0Yvj8tJDjAEhyekhZUTW9ZuBiNPNRqPr2FhyMAkyw64/7u6dPZVkcuKC2uYyhizjAOfWbBAFAVtQ+BypjMgBozCYDqXjcfl5gBVuESdUUXVQKuOJDagDI8rV79MwroAExM1/VT+LegRAAeg7l9/um/V0Q0805piijEx9diZDK3D8gAtAaEib5whu1AKIBr5rkAeB8WARovo6nET7b5g2AWlDNzwZGo8Epp97gYHI+1jIdgGhQdcgE6GJzCmtfQASg4yzxO1KWoVO4TqBaOeWE2w9Q1p8+/EPD1ISlhMYnNjx8uy7Zv38gCoC1NmpnatV97msADP+DVHscT+dXEYC2NjVcap80N99lpYCIq1vVIgdMLHQoZGiEPJ/5XGejoHRaCrgYr5z7U1cIYCx3TaZNGu+zWSgg5DyqOuQlYkOw9LaG5H6Snd4QQArL7p/sAV3D/TUzdJr6zeCQfe9h4fm7zZaWzS8s93lDEvKLTKU6QgMFApIO+z2ffh5ZUqflbK2bbvMPQm/mpI7tv7NP38p3feZuMgt01dqNxe7gv4tYtsB7cNO7R2OFvrZ2d9V9gvHurS/V+rxh6I0cTQKDxw8ltZNB/kMTdzuxz+GH53SftMRKARgbib9N+d9v9yxq4Y22jS/X+M+GoStnC0kgevL9Q1csHDydjlBNrY5rWr/1Vn8YeoG92L7z1dh7AN/HPb7aBo6uXvsC7/OGQLOcfsazmLg5N576Xqd8CyBh2xJpf333h25RBlHI8bzAl+kISP7j+179U3eK+r5D+/7lkwBKx/E8R2vkUTGa7KV07WvrCQGgywSe01EaeXgwvvTNP3zgFMdBaDme52gSEJ2H3tiT8euSeNzeIAAo5057AJw85R0DgIjfmeAld77zWptLBPJ0LC+whSTGo662HfudCSEnOmccmeGz/6XdLwGUjuUFloYiDU0OF/Hw2wd7QkCsVzk9Asf27HNIafd98d9bknTFLWXnvnQlLleEobKC6HX4kh8tKC3LmW4yKKfd3guBtGvchK+OXVDJ5wVcp/vSL4cgaIPpplv0Y27XGV8kOSDJFBuFCr3s8fQFg9Erf4lIcZYFpNfVG0uEoM0V5bLnixRXCJC0vpyvTH+NFGcxKS5XQE0ylJYVKm4ig063N+kqCNqgLxdMcDtcAVEGxVlNypeuVMeKuS9ls5Xc1wzZSk65bCWnXLaSUy5bySmXreSUy1ZyymUrOeWylZxy2UpOuWwlp1y2klMuW8kpl638B7627LfW6jufAAAAAElFTkSuQmCC",f="/docs/assets/image-20230424152041585-1ae033e2.png",g={},h=e('<h1 id="第二篇-响应系统" tabindex="-1"><a class="header-anchor" href="#第二篇-响应系统" aria-hidden="true">#</a> 第二篇 响应系统</h1><h2 id="第四章-响应系统的作用与实现" tabindex="-1"><a class="header-anchor" href="#第四章-响应系统的作用与实现" aria-hidden="true">#</a> 第四章 响应系统的作用与实现</h2><h3 id="_4-1-响应式数据与副作用函数" tabindex="-1"><a class="header-anchor" href="#_4-1-响应式数据与副作用函数" aria-hidden="true">#</a> 4.1 响应式数据与副作用函数</h3>',3),y={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},w=e(`<p><code>副作用函数</code>：当一个函数的执行会直接或间接影响其他函数的执行时，这个函数就是一个副作用函数。例子如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&quot;body&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，<em>effect()</em> 函数的执行会修改 body 的文本内容，但是这个文本内容并不是只有 <em>effect()</em> 函数才能修改的，因此这个函数的执行会直接或间接的影响其他函数的执行，它产生了副作用。其他例子如一个函数修改了一个全局变量，那么这个函数也是一个副作用函数。</p><p><code>响应式数据</code>：当这个数据变化时，依赖于它的函数或者说副作用函数会自动的重新执行，那么这个数据就是响应式数据。如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> count
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <em>count</em> 的值变化时，<em>effect()</em> 函数如果会自动执行的话，那么 <em>count</em> 就是一个响应式数据。</p><h3 id="_4-2-响应式数据的基本实现" tabindex="-1"><a class="header-anchor" href="#_4-2-响应式数据的基本实现" aria-hidden="true">#</a> 4.2 响应式数据的基本实现</h3>`,7),A={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},x=n("p",null,"整体思路分为两步，以上面的代码举例：",-1),j=n("ol",null,[n("li",null,[s("读取到 "),n("em",null,"count"),s(" 时，将函数 "),n("em",null,"effect"),s(" 保存起来")]),n("li",null,[s("当再次设置 "),n("em",null,"count"),s(" 时，将函数 "),n("em",null,"effect"),s(" 取出来执行")])],-1),E=n("code",null,"get",-1),F=n("code",null,"set",-1),q=e(`<p>这里我们采用<code>Proxy</code>来实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储副作用函数</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存副作用函数</span>
    bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码还有很多缺陷，但是也是一个简单的实现了。</p><h3 id="_4-3-设计一个完善的响应系统" tabindex="-1"><a class="header-anchor" href="#_4-3-设计一个完善的响应系统" aria-hidden="true">#</a> 4.3 设计一个完善的响应系统</h3>`,4),P={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},S=e(`<p>根据上一节的代码，我们要解决的第一个问题就是副作用函数，因为它不一定就是<em>effect</em>，也可能是别的名字，因此我们需要正确的收集副作用函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 存储副作用函数</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当调用 effect 时，注册副作用函数</span>
  activeEffect <span class="token operator">=</span> fn
  <span class="token comment">// 执行一次副作用函数</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成这一步后，我们就需要使用这个<em>effect</em>函数来注册副作用函数了。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 保存副作用函数</span>
      bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ok，完成这两步后，我们先试试看：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">effect</span><span class="token punctuation">(</span>myEff<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
</code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，目前这个副作用函数的名字为<em>myEff</em>，我们使用<em>effect</em>函数去注册它后，代码依然能正常运行。但是，它并不是没有问题，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// dataProxy 中并没有 name 属性</span>
dataProxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// 还是会输出 hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，当我们给一个并不存在的属性赋值时，还是会触发副作用函数，这显然是不合理的，因此，我们需要对存储副作用函数的<code>const bucket = new Set()</code>进行重新设计。</p><details class="hint-container details"><summary>设计 bucket 数据结构的一点思考</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中存在三个角色：</p><ol><li>被操作的对象：<code>dataProxy</code></li><li>被操作的属性，或者说字段：<code>text</code></li><li>副作用函数：<code>myEff</code></li></ol><p>它们之间的关系应该是如下的：<code>dataProxy -&gt; text -&gt; myEff</code>，即<strong>由 target 保存 key，由 key 保存 activeEffect</strong>（这里的 target 是<code>Proxy</code>中<code>get</code>和<code>set</code>的第一个参数，即代理的对象本身，key 是第二个参数，即操作的对象中的哪个字段，activeEffect 是副作用函数）。</p><p>如果是多个函数操作同一个字段的话，关系就是如下：<code>target -&gt; key -&gt; (activeEffect1, activeEffect2, ...)</code>，有点像一个树形结构：</p><div style="text-align:center;"><p><img src="`+d+`" alt="image-20230314224201381"></p></div><p>如果是多个字段对应同一个副作用函数、多个字段对应多个副作用函数等情况都与此类似。</p><p>总的来说，一个 target 可以对应 0-∞ 个字段，每个字段可以对应 0-∞ 个副作用函数，是一个此类的属性结构。</p><p>由此，我们来处理整个数据的结构如下，我们这里做个假设，代理的对象为<code>target</code>，每个字段为<code>key</code>，每个字段对应的所有副作用函数为<code>activeEffects</code>：</p><ol><li>我们知道，<code>Set</code>类型是没有键只有值的，且没有重复项，因此我们用它来保存每个<code>key</code>的对应的<code>activeEffects</code></li><li>让每个<code>key</code>和上面第一步中<code>activeEffects</code>的<code>Set</code>对应起来的数据我们使用<code>Map</code>类型来存储，因为<code>Map</code>可以让键值一一对应起来。</li><li>最后让每个<code>target</code>和它所有的<code>key</code>对应起来的数据我们使用<code>WeakMap</code>类型来存储，这里不使用<code>Map</code>类型的原因如下，(这个下面的<code>key</code>与上面的不一样，下面这里指的是<code>WeakMap</code>这个数据类型中笼统的键)： <ul><li><code>WeakMap</code>的<code>key</code>是弱引用，不会影响垃圾回收器的工作，一旦它的<code>key</code>被垃圾回收了，那么对应的<code>key: value</code>就访问不到了，因此它经常用于存储之后当<code>key</code>所引用的对象存在时（没有被垃圾回收）才有价值的信息，就如这里。当被代理的数据被垃圾回收后，它所对应的一系列关系就没有价值了。</li></ul></li></ol></details><p>综合上面设计 bucket 数据的思考，我们得到了这个保存<code>target -&gt; key -&gt; activeEffects</code>的数据结构如下：</p><table><thead><tr><th>数据类型</th><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td><code>WeakMap</code></td><td>bucket</td><td>保存<code>target</code>和它的所有<code>key</code>的关系，保存的是一个<code>Map</code>类型数据</td></tr><tr><td><code>Map</code></td><td>depsMap</td><td>保存<code>key</code>和它的所有<code>activeEffects</code>的关系，保存的是一个<code>Set</code>类型数据</td></tr><tr><td><code>Set</code></td><td>deps</td><td>保存每个<code>key</code>的所有<code>activeEffects</code>，只有所有的副作用函数</td></tr></tbody></table><details class="hint-container details"><summary>改造完的代码完整如下：</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储 target 和 key，保存的是一个 Map 类型</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当调用 effect 时，注册副作用函数</span>
  activeEffect <span class="token operator">=</span> fn
  <span class="token comment">// 执行一次副作用函数</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 没有 activeEffect，直接 return</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
    <span class="token comment">// key -&gt; effects</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
    <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
    deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 根据 target 取出 depsMap</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 根据 key 取出所有副作用函数</span>
    <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 取出副作用函数并执行</span>
    effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来验证下这个代码能否正确运行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 副作用函数</span>
<span class="token keyword">function</span> <span class="token function">myEff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
<span class="token punctuation">}</span>
<span class="token function">effect</span><span class="token punctuation">(</span>myEff<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">// hello</span>
dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// world</span>
dataProxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span> <span class="token comment">// 无输出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，当我们调用奴存在的字段时，并不会有输出了。</p><p>最后我们可以对上面的代码做一下封装，将<code>get</code>中处理数据的部分封装到<code>track</code>函数中，将<code>set</code>中处理数据的部分封装到<code>trigger</code>函数中：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 取出副作用函数并执行</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_4-4-分支切换与cleanup" tabindex="-1"><a class="header-anchor" href="#_4-4-分支切换与cleanup" aria-hidden="true">#</a> 4.4 分支切换与cleanup</h3>`,14),V={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},R=e(`<p><code>分支切换</code>：例如一个三元表达式<code>res.data ? true : false</code>，根据<code>res.data</code>值的不同，会执行不同的代码分支，这就是分支切换。</p><p>分支切换可能会产生遗留的副作用函数。如下面这个代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>cosnt data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">ok</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 一些代理的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> dataProxy<span class="token punctuation">.</span>ok <span class="token operator">?</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token string">&#39;not&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>dataProxy.ok</code>和<code>dataProxy.text</code>都绑定了<code>effectFn</code>，但是实际上，<code>dataProxy.text</code>由<code>dataProxy.ok</code>决定触发与否，即这里的理想情况为<code>dataProxy.text</code>的依赖集合中不应该收集这个<code>effectFn</code>，但是目前代码的实际情况却并不是如此的，即产生了遗留的副作用函数。它导致的问题为：当<code>dataProxy.ok</code>为 false 时，我们修改<code>dataProxy.text</code>的值也会触发这个<code>effectFn</code>。</p><p><strong>要解决这个问题的整体思路是：每次副作用函数执行时，我们先将它从所有与之关联的以来集合中删除，当副作用函数执行完毕后，重新建立联系，但在新的联系中不会包含遗留的副作用函数。</strong></p><p>因此我们首先需要修改注册副作用函数的<code>effect</code>函数，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个修改的主要思路是添加了<code>effectFn.deps</code>，它是一个数组，用来存储所有包含当前副作用函数的依赖集合。然后我们修改上面提取出来的<code>track</code>函数，让<code>effectFn.deps</code>能收集这些依赖集合：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token comment">// 将 deps 添加到 effectFn.deps 数组中。这里的 deps 就是我们想要的依赖集合</span>
  activeEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成<code>track</code>函数的改造后，我们就收集到了我们想要的依赖集合，它们保存在<code>effectFn.deps</code>中，因此我们就可以继续修改<code>effect</code>函数了，添加一个<code>cleanup</code>函数，用来将副作用函数从依赖集合中清除：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// cleanup 用来将副作用函数从依赖集合中清除</span>
<span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取出依赖集合</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token comment">// 将 effectFn 从这个集合中清除</span>
    deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重置 effectFn.deps 数组</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>effect</code>函数中调用<code>cleanup</code>方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// ... 其他代码</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... 其他代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在完成以上步骤后，此时运行代码会发现进入了死循环，这是因为**我们在<code>trigger</code>方法中遍历了<code>Set</code>类型，即遍历了有<code>effectFn</code>的依赖集合，但是在<code>effectFn</code>的运行时将其从这个集合中去掉了，完成后又添加了进去。**可以简单理解为如下这个代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

set<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;遍历set&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就会造成死循环。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>这个问题在语言规范中描述如下：</p><p><strong>在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。</strong></p><details class="hint-container details"><summary>解决办法如下：</summary><p>再构造一个<code>Set</code>并遍历它</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> newSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span>

newSet<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;遍历set&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里大家肯定会有点疑问，这个新的<code>Set</code>套了一个旧的<code>Set</code>，它俩数据结构都不一样，这个新的代替旧的遍历有什么用呢？其实不是啊，当我们把一个<code>Set</code>作为参数传递给另一个<code>Set</code>时，它俩的数据结构都是一样的，如下是上面<code>set</code>和<code>newSet</code>的输出：</p><div style="text-align:center;"><p><img src="`+r+`" alt="image-20230315152652086"></p></div></details></div><p>现在我们来改造<code>trigger</code>函数解决这个死循环问题：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，这套代码就可以按照预期运行了。</p><h3 id="_4-5-嵌套的-effect-与-effect-栈" tabindex="-1"><a class="header-anchor" href="#_4-5-嵌套的-effect-与-effect-栈" aria-hidden="true">#</a> 4.5 嵌套的 effect 与 effect 栈</h3>`,21),M={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},Q=e(`<p><code>effect</code>是可以发生嵌套的，如<code>effect(function() { effect(function() {}) })</code>。具体场景如：在 Vue 中，一个组件里面使用了另一个组件，这就会造成<code>effect</code>的嵌套，<strong>因为 Vue 的渲染函数就是在一个<code>effect</code>中执行的</strong>。所以<code>effect</code>需要设计成可嵌套的，但是目前我们实现的代码并不能支持这一功能，原因就在于<code>activeEffect</code>这个变量上。</p><p><code>activeEffect</code>这个变量是我们用来存储通过<code>effect</code>注册的副作用函数的，但是，它目前是一个全局变量，因此就导致我们每次存储的副作用函数只能有一个，当产生<code>effect</code>嵌套时，内层的副作用函数就会覆盖外层的，所以，我们需要一个栈类型的变量来存储这些要注册的副作用函数，因此，我们对<code>effect</code>和<code>activeEffect</code>的改造如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 这是一个副作用函数栈，用来存储要注册的副作用函数</span>
<span class="token keyword">let</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-6-避免无限递归循环" tabindex="-1"><a class="header-anchor" href="#_4-6-避免无限递归循环" aria-hidden="true">#</a> 4.6 避免无限递归循环</h3>`,4),z={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},N=e(`<p>这个问题简单来说就是避免<code>effect</code>函数自动的无线嵌套导致栈溢出。这种情况其实在使用时很容易遇到，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* 其他代码 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token comment">// dataProxy.count++ 相当于 dataProxy.count = dataproxy.count + 1</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在<code>effect</code>中使<code>dataProxy.count</code>自增，这就会导致我们我们读取<code>count</code>时触发<code>get</code>将副作用函数收集到栈中，然后给<code>count</code>赋值时触发<code>set</code>将副作用函数取出来执行，但是目前它本身就还在执行过程中，因此就又触发了<code>dataProxy.count++</code>，这就会无限递归下去，导致栈溢出。</p><p>这个 bug 其实不难解决，因为我们能发现这里问题的关键就在于在<code>get</code>和<code>set</code>中执行的都是同一个副作用函数，因此，我们只要在<code>set</code>中添加一个判断条件：当这个副作用函数正在执行时，就不在<code>set</code>中执行它。代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-7-调度执行" tabindex="-1"><a class="header-anchor" href="#_4-7-调度执行" aria-hidden="true">#</a> 4.7 调度执行</h3>`,6),B={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},C=e(`<p><code>可调度性</code>：当<code>trigger</code>方法触发时，或者说当被<code>Proxy</code>中的<code>set</code>行为被触发从而导致副作用函数执行时，我们有能力决定它执行的<strong>时机、次数和方式</strong>。这对于一个响应式系统来说是很重要的特性。</p><p>因此，我们在不改变当前代码结构的情况下，需要实现这个需求，则需要修改<code>effect</code>这个函数：给它设计一个选项参数 <em>options</em>，允许用户指定调度器。大致如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span>
	  <span class="token comment">// options</span>
	  <span class="token comment">// 调度器 scheduler 是一个函数</span>
	  <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">// ...</span>
	  <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在有了大致的修改框架后，我们就需要在<code>effect</code>函数内部将 <em>options</em> 挂载到对应的副作用函数上：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>我们这里设定 <em>options</em> 中的可能有一个方法<code>scheduler</code>，它的参数应该为副作用函数，用来帮助用户控制副作用函数的执行。</p><p>如果这个方法存在，则直接将副作用函数传递给它，否则副作用函数直接执行。</p></div><p>有了调度函数，我们在<code>trigger</code>函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，这样就可以将控制副作用函数执行的能力给到用户了：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果一个副作用函数存在调度器，则调用这个调度器，并将副作用函数作为参数传递</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在<code>trigger</code>中就添加了判断调度器<code>scheduler</code>是否存在的代码，存在则向它传递副作用函数，不存在则直接执行副作用函数。这个调度器就是用来帮用户控制副作用执行的。</p><details class="hint-container details"><summary>验证一下以上代码：</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// options</span>
  <span class="token punctuation">{</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下：</p><p><img src="`+k+`" alt="image-20230320151302642"></p><p>没有 <em>options</em> 的如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+v+`" alt="image-20230320151629236"></p></details><p>这里其实也有一个问题，比如我们这里有<code>dataProxy.count = 1</code>这个数据，我们在多次使其自增后，只想获取到它最后一次自增的结果，那么很明显我们现在的代码并不能满足这个需求。因为它会输出所有自增的结果。</p><p>那你也许会问，这有什么意义吗？其实是有的，就比如在 Vue 中，当我们连续多次修改了一个响应式数据后，它只会触发一次更新，因为它的中间过渡状态其实是我们不需要的。</p><p>我们先来看实现这个功能的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义一个任务队列</span>
<span class="token keyword">const</span> jobQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 使用 Promise.resolve() 创建一个 promise 实例</span>
<span class="token comment">// 用它将一个任务添加到微任务队列</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来标志是否正在刷新队列</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 用来刷新队列</span>
<span class="token keyword">function</span> <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果正在刷新，则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushing<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token comment">// 设置 isFlushing 为 true，表示正在刷新</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 在微任务队列中刷新 JobQueue 队列</span>
  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    jobQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结束后重置 isFlushing</span>
    isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
	下面是验证功能的代码
*/</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 每次调度时，将副作用函数添加到 jobQueue 队列中</span>
      jobQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
      <span class="token comment">// 调用 flushJob 刷新队列</span>
      <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span>
dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;over&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下：</p><div style="text-align:center;"><p><img src="`+m+'" alt="image-20230320154555333"></p></div><div class="hint-container tip"><p class="hint-container-title">详解</p><p>上面我们定义<code>JobQueue</code>这个队列为<code>Set</code>，主要是利用<code>Set</code>的自动去重能力。</p><p>然后定义一个微任务(<code>Promise.resolve()</code>)，它用来添加任务到微任务队列。</p><p>然后定义一个用于控制队列刷新的锁(<code>isFlushing</code>)，主要是控制队列不能重复刷新。</p><p>最后就是完成刷新队列方法(<code>flushJob</code>)。</p><p>我们在使用中，如果有 <em>options</em> 这个选项，则在<code>scheduler</code>方法中先将副作用函数添加到<code>JobQueue</code>队列中，然后调用刷新队列的方法<code>flushJob</code>。</p></div><h3 id="_4-8-计算属性-computed-与-lazy" tabindex="-1"><a class="header-anchor" href="#_4-8-计算属性-computed-与-lazy" aria-hidden="true">#</a> 4.8 计算属性 computed 与 lazy</h3>',18),I={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},J=e(`<p>首先，我们先总结下通过上面这些小节，我们目前拥有的函数方法：</p><ol><li><code>effect</code>：用来注册副作用函数的方法，它可以传入<code>options</code>，例如使用<code>scheduler</code>控制副作用函数的执行</li><li><code>track</code>：用来追踪和收集依赖</li><li><code>trigger</code>：用来重新触发副作用函数执行</li></ol><p>有了这些方法后，我们就可以实现 Vue 中的一个很有特色的功能：计算属性<code>computed</code>。</p><p>但是，在完成这个功能之前，我们首先来完成<code>effect</code>的懒执行。当前我们的<code>effect</code>函数是会立刻执行的，但是在某些情况下，我们不希望它立即执行，我们更希望它在该执行的时候执行，这就是懒执行。在使用时，我们可以通过给<code>options</code>提供参数<code>lazy: true</code>来开启这个功能。下面我们来实现这个功能：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在添加了懒执行的代码后，我们就可以在使用<code>effect</code>方法注册副作用函数后，在想让其执行的地方调用<code>effect</code>的返回值来执行副作用函数。如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 开启懒执行功能</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，其实能手动执行副作用函数这个功能意义并不大，因为我们直接在想执行的地方调用<code>effect</code>也是一样。但是，这个功能实现的意义在于，我们能获取到副作用函数返回的值了，如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，目前它返回的是 undefined，为了实现获取返回值的功能，我们还需要对<code>effect</code>做一些修改：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 将副作用函数的执行结果保存</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
    <span class="token comment">// 返回副作用函数的执行结果</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们再执行上面获取返回值的代码即可有正确的返回结果了：</p><div style="text-align:center;"><p><img src="`+b+'" alt="image-20230320162700317"></p></div>',13),T=n("code",null,"computed",-1),K={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get",target:"_blank",rel:"noopener noreferrer"},W=e(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 计算属性方法</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token comment">// 在 vue3 中，computed 返回的是一个 ref 对象，要使用 .value 才能读取具体值</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证下<code>computed</code>方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注</p><p>这个时候我们已经实现了简单的计算属性功能，但是，我们知道，vue 中的计算属性是可以缓存的，但是我们这里的值并不能缓存，因为我们目前实现的<code>computed</code>是只有读取<code>.value</code>时，它才会进行计算并得到值，所以每次调用<code>.value</code>，都会进行计算，即使<code>dataProxy.text</code>的值没有变化。</p></div><p>为了解决这个问题，我们就需要在实现<code>computed</code>方法时，添加对值进行缓存的功能，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 缓存值</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，很明显，这样会有一个问题，就是<code>isRecalculate</code>这个变量外部无法读取到，导致第一次计算后它就一直是 false，会导致后续即使<code>dataProxy.text</code>的值改变了，它也不会重新计算。</p><p>那么解决这个问题的关键就在于将<code>isRecalculate</code>设置为 true 就行了，那么怎么才能更改呢？不要忘了，<code>options</code>中可是有一个<code>scheduler</code>方法的，我们只要在这里面更改就可以解决问题啦：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hello world</span>

dataProxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// hi world</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">注</p><p>当<code>dataProxy.text</code>变化时，触发<code>trigger</code>方法，并进入到<code>effect.options.scheduler</code>存在的分支，触发<code>computed</code>中的这个<code>scheduler</code>，将<code>isRecalculate</code>置为 true，最后我们调用<code>.value</code>时，重新计算值并将其存储。</p></div><p>现在，这个<code>computed</code>已经近乎完美，但是确实还存在一个缺陷，也就是当我们在另一个<code>effect</code>中读取计算属性的值后，我们在其他地方修改这个计算属性依赖的值时，它应该会触发副作用函数的重新执行，但其实这里并没有，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count <span class="token operator">+</span> dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 我们期望这个地方输出 2hello，但实际这里没有任何输出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要解决这个问题，我们首先观察下上面的代码，可以发现，这是一个<code>effect</code>嵌套的问题，这个计算属性内部有自己的<code>effect</code>，然后我们在外部给他又套了一层<code>effect</code>，因此对于<code>computed</code>中的<code>getter</code>来说，它只会将<code>computed</code>内部的<code>effect</code>收集为依赖，而外部嵌套的它则不会收集。</p><p>因此，要解决这个问题其实也不难。就是<strong>当读取计算属性的值时，我们手动调用<code>track</code>函数进行追踪，当计算属性依赖的响应式数据改变时，手动调用<code>trigger</code>函数进行触发响应</strong>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 方法触发响应</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 当读取 value 时，手动调用 track 函数进行追踪</span>
      <span class="token function">track</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们再来验证下上面的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> comText <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count <span class="token operator">+</span> dataProxy<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comText<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 2hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，它就是正确符合我们预期的了。</p><h3 id="_4-9-watch-的实现原理" tabindex="-1"><a class="header-anchor" href="#_4-9-watch-的实现原理" aria-hidden="true">#</a> 4.9 watch 的实现原理</h3>`,21),U={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},G=e(`<p><code>watch</code>本质上就是观测响应式数据，当数据变化时通知并执行相应的回调函数。</p><p>格式如下：<code>watch(obj, () =&gt; {/* 其他代码 */})</code>，obj 是观测的响应式数据，回调函数是当数据变化时执行的。</p><p><strong>实际上，<code>watch</code>的实现本质上就是利用了<code>effect</code>以及<code>options.scheduler</code>选项</strong>。如下代码所示是一个简单的<code>watch</code>的实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们能很容易的看出来，这是个代码是有问题的，因为上面我们硬编码观测的是<code>dataProxy.count</code>，所以，首先我们先解决传入的问题是一个对象，如<code>dataProxy</code>时，我们需要递归读取它上面的属性，从而当任意属性发生变化时都能触发回调函数执行，这个递归的方法我们将其命名为<code>traverse</code>，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归方法，用来读取 watch 中传入的对象的属性</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// seen 用来保存已经读取过的属性</span>
  <span class="token comment">// 如果传入的数据是原始数据类型，或者已经被读取过了，则什么都不做</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 将读取了的属性存储到 seen 中，避免循环引用</span>
  seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token comment">// 暂时不考虑数组等其他结构</span>
  <span class="token comment">// 假设 value 是一个对象，使用 for...in 读取对象的每一个值，并递归调用 traverse 方法</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> seen<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>dataProxy<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>目前，我们实现了非硬编码观测对象的能力，但是，我们知道，<code>watch</code>不仅能传入一个对象，也能传入一个<code>getter</code>函数，如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;dataProxy.count改变了&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>因此，<code>watch</code>函数修改如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>ok，目前，我们也完成了传递<code>getter</code>函数的功能，现在，还有一个功能我们没有完成，也就是<code>watch</code>中获取到被观测数据改变前后的值，即<code>oldValue</code>和<code>newValue</code>。</p><p>现在我们来完成这个功能：</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
        newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
        cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
        <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
        oldValue <span class="token operator">=</span> newValue
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
  <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
  oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

dataProxy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 响应式数据改变了 2 1</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是这个<code>watch</code>方法的基本实现了。</p><h3 id="_4-10-立即执行的-watch-与回调执行时机" tabindex="-1"><a class="header-anchor" href="#_4-10-立即执行的-watch-与回调执行时机" aria-hidden="true">#</a> 4.10 立即执行的 watch 与回调执行时机</h3>`,13),O={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},X=e(`<p>上节我们完成了<code>watch</code>方法的基本实现，其本质就是对<code>effect</code>的二次封装。本节我们继续完成<code>watch</code>的两个特性：</p><ol><li>立即执行的回调函数</li><li>回调函数的执行时机</li></ol><p>默认情况下，<code>watch</code>方法的回调函数只在被观测的数据变化时才会触发，但是，在 vue 中，<code>watch</code>可以通过传入<code>immediate</code>参数来指定回调是否需要立即执行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;变化了&quot;</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了完成这个功能，我们需要改造<code>watch</code>函数，在其中添加<code>options.immediate</code>的判断：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token literal-property property">scheduler</span><span class="token operator">:</span> job
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> dataProxy<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">oldValue<span class="token punctuation">,</span> newValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;响应式数据改变了&quot;</span><span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span> <span class="token comment">// 响应式数据改变了 1 undefined</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，我们就完成了回调函数立即执行的功能。</p><p>现在，我们就来完成执行回调函数执行时机的功能，同样的，我们也需要使用一个<code>options</code>参数来实现，在 vue 中，这个参数是<code>flush</code>，它有三个值：<code>pre | post | sync</code>。</p>`,8),Y=n("code",null,"Promise.resolve()",-1),H=e(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上述代码，我们实现了<code>flush === &#39;post&#39;</code>的情况，而剩下的<code>sync</code>就是同步执行，至于<code>pre</code>，它涉及到组件的更新时机，目前没办法模拟。</p><h3 id="_4-11-过期的副作用" tabindex="-1"><a class="header-anchor" href="#_4-11-过期的副作用" aria-hidden="true">#</a> 4.11 过期的副作用</h3>`,3),D={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?",target:"_blank",rel:"noopener noreferrer"},L=e(`<p>举个例子，我们发送了一次网络请求，那么在这一次请求的结果还没有返回时，我们又重新发送了一次请求，那么，前一次的请求就是过期的。拿副作用函数来说就是前一次的副作用函数还没有执行完成时，有了新的副作用函数执行，那么前一次的就是过期的副作用。</p><p>因此我们就需要一个让副作用过期的手段，不执行过期的副作用。在 vue 中，<code>watch</code>的回调函数接收第三个参数<code>onInvalidate</code>，这个参数是一个函数，类似于事件监听器，我们可以使用<code>onInvalidate</code>注册一个回调，这个回调函数会在当前副作用函数过期时执行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表未过期</span>
  <span class="token keyword">let</span> expired <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// 调用 onInvalidate() 函数注册一个过期的回调</span>
  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当过期时，将 expired 置为 true</span>
    expired <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token comment">// 网络请求</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;url&#39;</span><span class="token punctuation">)</span>
  <span class="token comment">// 当该副作用函数的执行还没有过期时，才会执行后续操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如上面的代码，我们在发送请求前就先定义一个变量<code>expired</code>来标识这次的副作用函数的执行是否过期，然后使用<code>onInvalidate</code>函数注册一个过期时的回调，用来改变<code>expired</code>的值。然后再发送请求，并判断是否过期，未过期则执行其他后续操作。</p></blockquote><p>下面，我们来改造<code>watch</code>函数，给它的回调函数添加<code>onInvalidate</code>函数参数。这个函数的<strong>原理就是在<code>watch</code>内部每次检测到变更后，在副作用函数重新执行之前，会先调用通过<code>onInvalidate</code>注册的过期时的回调函数</strong>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 定义 cleanup 变量用来存储用户注册的过期回调函数，这跟我们在外面定义的 cleanup 全局方法不一样</span>
  <span class="token keyword">let</span> cleanup
  <span class="token comment">// 定义 onInvalidate 函数</span>
  <span class="token keyword">function</span> <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将过期的回调存储到 cleanup 中</span>
    cleanup <span class="token operator">=</span> fn
  <span class="token punctuation">}</span>

  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用回调函数前，清除过期回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cleanup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数，将 onInvalidate 作为第三个参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注</p><p>上面定义了一个变量<code>cleanup</code>，它与上面我们用来将副作用函数从依赖集合中清除的<code>cleanup()</code>方法不同，这里它用来保存我们通过<code>onInvalidate</code>函数注册的副作用过期时的回调。</p></div><h3 id="第四章的完整代码" tabindex="-1"><a class="header-anchor" href="#第四章的完整代码" aria-hidden="true">#</a> 第四章的完整代码</h3><details class="hint-container details"><summary>完整代码</summary><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原始数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储 target 和 key，保存的是一个 Map 类型</span>
<span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// cleanup 用来将副作用函数从依赖集合中清除</span>
<span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取出依赖集合</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token comment">// 将 effectFn 从这个集合中清除</span>
    deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重置 effectFn.deps 数组</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用来存储被注册的副作用函数</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 这是一个副作用函数栈，用来存储要注册的副作用函数</span>
<span class="token keyword">let</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// effect 函数用来注册副作用函数</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 cleanup 方法</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 当 effectFn执行时，将其设置为当前激活的副总用函数</span>
    activeEffect <span class="token operator">=</span> effectFn
    <span class="token comment">// 将注册的副作用函数压入栈内</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">// 将副作用函数的执行结果保存</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这个副作用函数执行完后，将其从栈内取出，</span>
    <span class="token comment">// 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前副作用函数执行后弹出</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 还原 activeEffect 为原值</span>
    <span class="token comment">// 返回副作用函数的执行结果</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 options 挂载到 effectFn 上</span>
  effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
  <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 判断是否懒执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未开启懒执行功能，则直接执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回副作用函数</span>
  <span class="token keyword">return</span> effectFn
<span class="token punctuation">}</span>

<span class="token comment">// 在 get 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有 activeEffect，直接 return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型</span>
  <span class="token comment">// key -&gt; effects</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果 depsMap 不存在，根据 target 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span>
  <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数</span>
  <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果 deps 不存在，根据 key 新建一个</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后将当前激活的副作用函数存入 deps 中</span>
  deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token comment">// 将 deps 添加到 effectFn.deps 数组中。这里的 deps 就是我们想要的依赖集合</span>
  activeEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 set 方法中调用，追踪变化</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 target 取出 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 根据 key 取出所有副作用函数</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newEffects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 循环判断副作用函数</span>
  effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤</span>
    <span class="token comment">// 否则不执行任何操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newEffects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 代替 effects 进行遍历</span>
  newEffects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果一个副作用函数存在调度器，则调用这个调度器，并将副作用函数作为参数传递</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对数据进行代理</span>
<span class="token keyword">const</span> dataProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拦截数据的读取操作</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 返回读取的属性值，Reflect 可以查看上面 Proxy 链接</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 拦截数据的赋值操作</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// set 方法需要返回一个 boolean</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 定义一个任务队列</span>
<span class="token keyword">const</span> jobQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 使用 Promise.resolve() 创建一个 promise 实例</span>
<span class="token comment">// 用它将一个任务添加到微任务队列</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 用来标志是否正在刷新队列</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 用来刷新队列</span>
<span class="token keyword">function</span> <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果正在刷新，则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushing<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token comment">// 设置 isFlushing 为 true，表示正在刷新</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 在微任务队列中刷新 JobQueue 队列</span>
  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    jobQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结束后重置 isFlushing</span>
    isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 计算属性方法</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来缓存上一次计算的值</span>
  <span class="token keyword">let</span> value
  <span class="token comment">// 用来标记是否需要重新计算，默认为 true，以便第一次进行计算</span>
  <span class="token keyword">let</span> isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 方法触发响应</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当读取 value 时才是行 effectFn</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecalculate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        isRecalculate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 当读取 value 时，手动调用 track 函数进行追踪</span>
      <span class="token function">track</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>

<span class="token comment">// watch方法，观测数据</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 getter</span>
  <span class="token keyword">let</span> getter
  <span class="token comment">// 如果 source 是函数，则说明用户传递的是 getter 函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> source
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则调用 traverse 方法</span>
    <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 定义新值和旧值</span>
  <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
  <span class="token comment">// 定义 cleanup 变量用来存储用户注册的过期回调函数，这跟我们在外面定义的 cleanup 全局方法不一样</span>
  <span class="token keyword">let</span> cleanup
  <span class="token comment">// 定义 onInvalidate 函数</span>
  <span class="token keyword">function</span> <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将过期的回调存储到 cleanup 中</span>
    cleanup <span class="token operator">=</span> fn
  <span class="token punctuation">}</span>

  <span class="token comment">// 提取 scheduler 调度函数为一个独立的函数 job</span>
  <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
    newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用回调函数前，清除过期回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cleanup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将旧值和新值作为回调函数的参数，将 onInvalidate 作为第三个参数</span>
    cb <span class="token operator">&amp;&amp;</span> <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span>
    <span class="token comment">// 更新旧值，以便下一次获取旧值时时正确的</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
  <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
    <span class="token comment">// 执行 getter</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">lazy</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，则将其放到微任务队列中执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

  <span class="token comment">// 判断 immediate 是否为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手动调用副作用函数，得到的就是旧值</span>
    oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归方法，用来读取 watch 中传入的对象的属性</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// seen 用来保存已经读取过的属性</span>
  <span class="token comment">// 如果传入的数据是原始数据类型，或者已经被读取过了，则什么都不做</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 将读取了的属性存储到 seen 中，避免循环引用</span>
  seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token comment">// 暂时不考虑数组等其他结构</span>
  <span class="token comment">// 假设 value 是一个对象，使用 for...in 读取对象的每一个值，并递归调用 traverse 方法</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> seen<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="第五章-非原始值的响应式方案" tabindex="-1"><a class="header-anchor" href="#第五章-非原始值的响应式方案" aria-hidden="true">#</a> 第五章 非原始值的响应式方案</h2><p>通过上一章我们了解到了响应系统的概念与实现，并简单介绍了响应式数据的基本原理。</p><p>这一章我们就专注与响应式数据本身，深入探讨实现响应式数据都需要考虑哪些内容，其中的难点又是什么。</p><p>实际上实现响应式数据是很难的，并不是简单的<code>get/set</code>操作即可，还有例如拦截<code>for...in</code>循环，代理<code>Map | Set | WeakMap | WeakSet</code>等数据类型。</p><h3 id="_5-1-理解-proxy-和-reflect" tabindex="-1"><a class="header-anchor" href="#_5-1-理解-proxy-和-reflect" aria-hidden="true">#</a> 5.1 理解 Proxy 和 Reflect</h3>`,14),Z={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3",target:"_blank",rel:"noopener noreferrer"},_=e("<p><code>Proxy</code>可以创建一个代理对象，它能够实现对其他对象的代理，但是也 <strong>只能代理对象，无法代理如<code>string | boolean | number</code></strong> 等原始值。</p><p>代理：指的是对一个对象基本语义（或者说基本操作，如读取、赋值）的代理，它允许我们拦截并重新定义对一个对象的基本操作。</p><p><code>Reflect</code>是一个全局对象，其有许多方法。任何在<code>Proxy</code>的拦截器中能够找到的方法，都能够在<code>Reflect</code>中找到同名函数。</p>",3),$={href:"http://localhost:8080/docs/ts/Proxy%E5%92%8CReflect.html",target:"_blank",rel:"noopener noreferrer"},nn=n("h3",{id:"_5-2-javascript-对象及-proxy-的工作原理",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_5-2-javascript-对象及-proxy-的工作原理","aria-hidden":"true"},"#"),s(" 5.2 JavaScript 对象及 Proxy 的工作原理")],-1),sn={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3?",target:"_blank",rel:"noopener noreferrer"},an=e('<p>这一节主要讲解了 <strong>ECMAScript 规范</strong> 中 JavaScript 中的两种对象：</p><ol><li>常规对象：满足以下三点要求的对象就是常规对象。 <ul><li>必须使用 ECMA 规范10.1.x给出的定义实现</li><li>对于内部方法<code>[[Call]]</code>，必须使用 ECMA 规范10.2.1给出的定义实现</li><li>对于内部方法<code>[[Construct]]</code>，必须使用 ECMA 规范10.2.2给出的定义实现</li></ul></li><li>异质对象：所有不属于常规对象的对象都是异质对象。</li></ol><p>区分函数对象和普通对象：通过内部方法和内部槽来区分。函数对象会部署内部方法<code>[[Call]]</code>，而普通对象不会。</p><p>Proxy 对象内部的方法<code>[[Get]]</code>没有使用 ECMA 规范的10.1.8给出的定义实现，所以 Proxy 是一个异质对象。</p><p><strong>内部方法的多态性</strong>：不同对象有同样的内部方法，但是这些内部方法的实现方式又有不同。</p><p>创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来自定义被代理对象的内部方法和行为的。即我们代理了一个对象<code>obj</code>，代理对象就是<code>objProxy</code>，被代理对象就是<code>obj</code>，我们指定的拦截函数是给<code>objProxy</code>的，而<code>obj</code>其实没什么变化。</p><h3 id="_5-3-如何代理-object" tabindex="-1"><a class="header-anchor" href="#_5-3-如何代理-object" aria-hidden="true">#</a> 5.3 如何代理 Object</h3>',7),en={href:"https://weread.qq.com/web/reader/c5c32170813ab7177g0181aek65132ca01b6512bd43d90e3?",target:"_blank",rel:"noopener noreferrer"},tn=n("p",null,"下面是一些对普通对象的所有可能的读取操作：",-1),pn=n("ol",null,[n("li",null,"访问属性：obj.foo"),n("li",null,"判断对象或原型上是否存在给定的 key：key in obj"),n("li",null,"使用 for...in 遍历对象：for (const key in obj) {}")],-1),cn=n("p",null,[s("下面就逐步讨论如何拦截上面这些读取操作。首先是属性的读取，我们知道可以使用"),n("code",null,"get"),s("来进行拦截。")],-1),on=n("code",null,"in",-1),ln=e(`<blockquote><p><code>in</code>操作符的运算结果是通过调用一个叫做<code>HasProperty</code>的抽象方法得到的。关于这个抽象方法，可以在 ECMA-262 规范的 7.3.11 中找到。</p><p><code>HasProperty</code>抽象方法的返回值是通过调用对象内部的<code>[[HasProperty]]</code>得到的。这个内部方法对应的拦截函数为<code>has</code>。</p></blockquote><p><strong>因此我们可以通过<code>has</code>拦截函数实现对<code>in</code>操作符的代理。</strong> 如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token string">&#39;foo&#39;</span> <span class="token keyword">in</span> p <span class="token comment">// 会建立依赖关系</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面我们知晓了<code>in</code>操作符的拦截，那么<code>for...in</code>呢。</p><p>通过上面那个链接，我们能直接得到答案，使用<code>ownKeys</code>方法即可拦截<code>for...in</code>操作。至于原因，如下：</p><details class="hint-container details"><summary>详情</summary><p><img src="`+f+`" alt="image-20230424152041584"></p></details><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">ITERATE_KEY</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将副作用函数与 ITERATE_KEY 关联</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">为什么使用 ITERATE_KEY 作为追踪的 key</p><p>因为<code>ownKeys</code>拦截函数与<code>get/set</code>不同，在<code>get/set</code>中，我们可以得到具体操作的 key，但是在<code>ownKeys</code>中，我们只能拿到目标对象的 target。</p><p>这里追踪的是 ITERATE_KEY，那么在触发响应时也应该用它：<code>trigger(target, ITERATE_KEY)</code></p></div><h2 id="第六章-原始值的响应式方案" tabindex="-1"><a class="header-anchor" href="#第六章-原始值的响应式方案" aria-hidden="true">#</a> 第六章 原始值的响应式方案</h2>`,9);function un(dn,rn){const t=o("ExternalLinkIcon"),p=o("RouterLink");return l(),u("div",null,[h,n("p",null,[n("a",y,[s("4.1 响应式数据与副作用函数"),a(t)])]),w,n("p",null,[n("a",A,[s("4.2 响应式数据的基本实现"),a(t)])]),x,j,n("p",null,[s("这两步的关键点就在于拦截数据，即我们能手动控制数据的读取("),E,s(")和设置("),F,s(")两个操作。在 ES2015 前，我们只能通过"),a(p,{to:"/js/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.html"},{default:c(()=>[s("Object.defineProperty()")]),_:1}),s("函数实现，也就是 Vue2 采用的方式，但是在 ES2015+ 后，我们可以使用代理对象"),a(p,{to:"/ts/Proxy%E5%92%8CReflect.html"},{default:c(()=>[s("Proxy")]),_:1}),s("来实现了，也就是 Vue3 采用的方式。")]),q,n("p",null,[n("a",P,[s("4.3 设计一个完善的响应系统"),a(t)])]),S,n("p",null,[n("a",V,[s("4.4 分支切换与cleanup"),a(t)])]),R,n("p",null,[n("a",M,[s("4.5 嵌套的 effect 与 effect 栈"),a(t)])]),Q,n("p",null,[n("a",z,[s("4.6 避免无限递归循环"),a(t)])]),N,n("p",null,[n("a",B,[s("4.7 调度执行"),a(t)])]),C,n("p",null,[n("a",I,[s("4.8 计算属性 computed 与 lazy"),a(t)])]),J,n("p",null,[s("好了，目前我们终于实现了懒执行的副作用函数，也能拿到它的执行结果了。那么现在就让我们来完成"),T,s("吧："),n("a",K,[s("getter | MDN"),a(t)])]),W,n("p",null,[n("a",U,[s("4.9 watch 的实现原理"),a(t)])]),G,n("p",null,[n("a",O,[s("4.10 立即执行的 watch 与回调执行时机"),a(t)])]),X,n("p",null,[s("要实现控制执行时机，其实我们在"),a(p,{to:"/vue3/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F.html#_4-7-%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C"},{default:c(()=>[s("4.7 调度执行")]),_:1}),s("中提到过，使用"),Y,s("方法，将要执行的方法添加到微队列中即可。实现如下：")]),H,n("p",null,[n("a",D,[s("4.11 过期的副作用"),a(t)])]),L,n("p",null,[n("a",Z,[s("5.1 理解 Proxy 和 Reflect"),a(t)])]),_,n("p",null,[n("a",$,[s("Proxy 和 Reflect"),a(t)])]),nn,n("p",null,[n("a",sn,[s("5.2 JavaScript 对象及 Proxy 的工作原理"),a(t)])]),an,n("p",null,[n("a",en,[s("5.3 如何代理 Object"),a(t)])]),tn,pn,cn,n("p",null,[s("但是"),on,s("操作符呢？"),a(p,{to:"/ts/Proxy%E5%92%8CReflect.html"},{default:c(()=>[s("Proxy 中拦截各种情况的函数")]),_:1})]),ln])}const vn=i(g,[["render",un],["__file","第二篇响应系统.html.vue"]]);export{vn as default};
