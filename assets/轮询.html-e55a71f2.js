import{_ as t,W as e,X as p,Y as s,Z as n,$ as o,a1 as c,a0 as i,C as l}from"./framework-4f54a744.js";const u={},r=i(`<h1 id="轮询" tabindex="-1"><a class="header-anchor" href="#轮询" aria-hidden="true">#</a> 轮询</h1><p>为了实现客户端实时获取到服务端的最新信息，我们可以使用轮询这一方法。简单理解就是客户端<strong>持续主动</strong>给服务端发送请求，以获取最新数据。</p><p>常见的轮询方式分为短轮询和长轮询，区别就是：</p><ul><li>短轮询是每隔一段时间就发送一次请求</li><li>长轮询就是没有间隔时间，每次客户端得到服务端返回的信息后就立马发送新的请求</li></ul><h2 id="轮询实现代码" tabindex="-1"><a class="header-anchor" href="#轮询实现代码" aria-hidden="true">#</a> 轮询实现代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">polling</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">sign</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 登录失败</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&#39;登录失败&#39;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>code <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 登录成功</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未得到登录失败或成功的消息</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">polling</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">注</p><p>上面的代码是一个短轮询，当我们没有得到具体的登录成功或失败的信息时，每隔 500ms 就向服务器发送请求获取信息。</p></div><h2 id="轮询的缺点" tabindex="-1"><a class="header-anchor" href="#轮询的缺点" aria-hidden="true">#</a> 轮询的缺点</h2><p>轮询的模式有很明显的缺点：客户端需要不断的往服务器发送请求，然而<code>http</code>请求与响应可能会包含较长的头部，其中真正有用的信息只有很小的一部分，其他无用的数据都是在浪费带宽资源。</p>`,9),k=s("code",null,"HTML5",-1);function d(v,m){const a=l("RouterLink");return e(),p("div",null,[r,s("p",null,[n("为了解决这一问题，"),k,n("定义了"),o(a,{to:"/js/WebSocket.html"},{default:c(()=>[n("WebSocket协议")]),_:1}),n("，能更好的节省服务器资源和带宽，并且能够更加实时的进行通讯。")])])}const b=t(u,[["render",d],["__file","轮询.html.vue"]]);export{b as default};
