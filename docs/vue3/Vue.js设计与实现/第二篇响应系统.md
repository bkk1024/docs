# 响应系统

## 第四章 响应系统的作用与实现

### 4.1 响应式数据与副作用函数

[4.1 响应式数据与副作用函数](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

`副作用函数`：当一个函数的执行会直接或间接影响其他函数的执行时，这个函数就是一个副作用函数。例子如下：

```js
function effect() {
  document.body.innerText = "body"
}
```

上面的代码中，*effect()*函数的执行会修改 body 的文本内容，但是这个文本内容并不是只有*effect()*函数才能修改的，因此这个函数的执行会直接或间接的影响其他函数的执行，它产生了副作用。其他例子如一个函数修改了一个全局变量，那么这个函数也是一个副作用函数。

`响应式数据`：当这个数据变化时，依赖于它的函数或者说副作用函数会自动的重新执行，那么这个数据就是响应式数据。如：

```js
let count = 0
function effect() {
  document.body.innerText = count
}
```

当*count*的值变化时，*effect()*函数如果会自动执行的话，那么*count*就是一个响应式数据。

### 4.2 响应式数据的基本实现

[4.2 响应式数据的基本实现](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

整体思路分为两步，以上面的代码举例：

1. 读取到*count*时，将函数*effect*保存起来
2. 当再次设置*count*时，将函数*effect*取出来执行

这两步的关键点就在于拦截数据，即我们能手动控制数据的读取(`get`)和设置(`set`)两个操作。在 ES2015 前，我们只能通过[Object.defineProperty()](../../js/属性描述符.md)函数实现，也就是 Vue2 采用的方式，但是在 ES2015+ 后，我们可以使用代理对象[Proxy](../../ts/Proxy和Reflect.md)来实现了，也就是 Vue3 采用的方式。

这里我们采用`Proxy`来实现：

```js
// 原始数据
const data = {
  text: 'hello'
}

// 存储副作用函数
const bucket = new Set()

// 对数据进行代理
const dataProxy = new Proxy(data, {
  // 拦截数据的读取操作
  get(target, key, receiver) {
    // 保存副作用函数
    bucket.add(effect)
    // 返回读取的属性值，Reflect 可以查看上面 Proxy 链接
    return Reflect.get(target, key, receiver)
  },

  // 拦截数据的赋值操作
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver)
    // 取出副作用函数并执行
    bucket.forEach(fn => fn())
    // set 方法需要返回一个 boolean
    return result
  }
})

// 副作用函数
function effect() {
  console.log(dataProxy.text)
}

console.log(dataProxy.text) // hello
dataProxy.text = "world" // world
```

这个代码还有很多缺陷，但是也是一个简单的实现了。

### 4.3 设计一个完善的响应系统

[4.3 设计一个完善的响应系统](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

根据上一节的代码，我们要解决的第一个问题就是副作用函数，因为它不一定就是*effect*，也可能是别的名字，因此我们需要正确的收集副作用函数。

```js
// 存储副作用函数
const bucket = new Set()
// 用来存储被注册的副作用函数
let activeEffect = null
// effect 函数用来注册副作用函数
function effect(fn) {
  // 当调用 effect 时，注册副作用函数
  activeEffect = fn
  // 执行一次副作用函数
  fn()
}
```

完成这一步后，我们就需要使用这个*effect*函数来注册副作用函数了。

```js{7}
// 对数据进行代理
const dataProxy = new Proxy(data, {
  // 拦截数据的读取操作
  get(target, key, receiver) {
    if (activeEffect) {
      // 保存副作用函数
      bucket.add(activeEffect)
    }
    // 返回读取的属性值，Reflect 可以查看上面 Proxy 链接
    return Reflect.get(target, key, receiver)
  },

  // 拦截数据的赋值操作
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver)
    // 取出副作用函数并执行
    bucket.forEach(fn => fn())
    // set 方法需要返回一个 boolean
    return result
  }
})
```

ok，完成这两步后，我们先试试看：

```js{5}
// 副作用函数
function myEff() {
  console.log(dataProxy.text)
}
effect(myEff)

console.log(dataProxy.text) // hello
dataProxy.text = "world" // world
```

可以看到，目前这个副作用函数的名字为*myEff*，我们使用*effect*函数去注册它后，代码依然能正常运行。但是，它并不是没有问题，如下：

```js
// dataProxy 中并没有 name 属性
dataProxy.name = "world" // 还是会输出 hello
```

可见，当我们给一个并不存在的属性赋值时，还是会触发副作用函数，这显然是不合理的，因此，我们需要对存储副作用函数的`const bucket = new Set()`进行重新设计。

:::: details 设计 bucket 数据结构的一点思考

```js
function myEff() {
  console.log(dataProxy.text)
}
```

这段代码中存在三个角色：

1. 被操作的对象：`dataProxy`
2. 被操作的属性，或者说字段：`text`
3. 副作用函数：`myEff`

它们之间的关系应该是如下的：`dataProxy -> text -> myEff`，即**由 target 保存 key，由 key 保存 activeEffect**（这里的 target 是`Proxy`中`get`和`set`的第一个参数，即代理的对象本身，key 是第二个参数，即操作的对象中的哪个字段，activeEffect 是副作用函数）。

如果是多个函数操作同一个字段的话，关系就是如下：`target -> key -> (activeEffect1, activeEffect2, ...)`，有点像一个树形结构：

::: center

![image-20230314224201381](./第二篇响应系统.assets/image-20230314224201381.png)

:::

如果是多个字段对应同一个副作用函数、多个字段对应多个副作用函数等情况都与此类似。

总的来说，一个 target 可以对应 0-∞ 个字段，每个字段可以对应 0-∞ 个副作用函数，是一个此类的属性结构。

由此，我们来处理整个数据的结构如下，我们这里做个假设，代理的对象为`target`，每个字段为`key`，每个字段对应的所有副作用函数为`activeEffects`：

1. 我们知道，`Set`类型是没有键只有值的，且没有重复项，因此我们用它来保存每个`key`的对应的`activeEffects`
2. 让每个`key`和上面第一步中`activeEffects`的`Set`对应起来的数据我们使用`Map`类型来存储，因为`Map`可以让键值一一对应起来。
3. 最后让每个`target`和它所有的`key`对应起来的数据我们使用`WeakMap`类型来存储，这里不使用`Map`类型的原因如下，(这个下面的`key`与上面的不一样，下面这里指的是`WeakMap`这个数据类型中笼统的键)：
   - `WeakMap`的`key`是弱引用，不会影响垃圾回收器的工作，一旦它的`key`被垃圾回收了，那么对应的`key: value`就访问不到了，因此它经常用于存储之后当`key`所引用的对象存在时（没有被垃圾回收）才有价值的信息，就如这里。当被代理的数据被垃圾回收后，它所对应的一系列关系就没有价值了。

::::

综合上面设计 bucket 数据的思考，我们得到了这个保存`target -> key -> activeEffects`的数据结构如下：

| 数据类型  | 变量名  | 作用                                                         |
| --------- | ------- | ------------------------------------------------------------ |
| `WeakMap` | bucket  | 保存`target`和它的所有`key`的关系，保存的是一个`Map`类型数据 |
| `Map`     | depsMap | 保存`key`和它的所有`activeEffects`的关系，保存的是一个`Set`类型数据 |
| `Set`     | deps    | 保存每个`key`的所有`activeEffects`，只有所有的副作用函数     |

::: details 改造完的代码完整如下：

```js{7,24-39,47-53}
// 原始数据
const data = {
  text: 'hello'
}

// 存储 target 和 key，保存的是一个 Map 类型
const bucket = new WeakMap()
// 用来存储被注册的副作用函数
let activeEffect = null
// effect 函数用来注册副作用函数
function effect(fn) {
  // 当调用 effect 时，注册副作用函数
  activeEffect = fn
  // 执行一次副作用函数
  fn()
}

// 对数据进行代理
const dataProxy = new Proxy(data, {
  // 拦截数据的读取操作
  get(target, key, receiver) {
    // 没有 activeEffect，直接 return
    if (!activeEffect) return Reflect.get(target, key, receiver)
    // 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型
    // key -> effects
    let depsMap = bucket.get(target)
    // 如果 depsMap 不存在，根据 target 新建一个
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()))
    }
    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
    // 里面存储着所有与当前 key 相关联的副作用函数
    let deps = depsMap.get(key)
    // 如果 deps 不存在，根据 key 新建一个
    if (!deps) {
      depsMap.set(key, (deps = new Set()))
    }
    // 最后将当前激活的副作用函数存入 deps 中
    deps.add(activeEffect)
    // 返回读取的属性值，Reflect 可以查看上面 Proxy 链接
    return Reflect.get(target, key, receiver)
  },

  // 拦截数据的赋值操作
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver)
    // 根据 target 取出 depsMap
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 根据 key 取出所有副作用函数
    const effects = depsMap.get(key)
    // 取出副作用函数并执行
    effects && effects.forEach(fn => fn())
    // set 方法需要返回一个 boolean
    return result
  }
})
```

再来验证下这个代码能否正确运行：

```js
// 副作用函数
function myEff() {
  console.log(dataProxy.text) // hello
}
effect(myEff)

console.log(dataProxy.text) // hello
dataProxy.text = "world" // world
dataProxy.name = "world" // 无输出
```

可以看到，当我们调用奴存在的字段时，并不会有输出了。

最后我们可以对上面的代码做一下封装，将`get`中处理数据的部分封装到`track`函数中，将`set`中处理数据的部分封装到`trigger`函数中：

```js{1-32}
// 在 get 方法中调用，追踪变化
function track(target, key) {
  // 没有 activeEffect，直接 return
  if (!activeEffect) return Reflect.get(target, key, receiver)
  // 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型
  // key -> effects
  let depsMap = bucket.get(target)
  // 如果 depsMap 不存在，根据 target 新建一个
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
  // 里面存储着所有与当前 key 相关联的副作用函数
  let deps = depsMap.get(key)
  // 如果 deps 不存在，根据 key 新建一个
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 最后将当前激活的副作用函数存入 deps 中
  deps.add(activeEffect)
}

// 在 set 方法中调用，追踪变化
function trigger(target, key) {
  // 根据 target 取出 depsMap
  const depsMap = bucket.get(target)
  if (!depsMap) return
  // 根据 key 取出所有副作用函数
  const effects = depsMap.get(key)
  // 取出副作用函数并执行
  effects && effects.forEach(fn => fn())
}

// 对数据进行代理
const dataProxy = new Proxy(data, {
  // 拦截数据的读取操作
  get(target, key, receiver) {
    track(target, key)
    // 返回读取的属性值，Reflect 可以查看上面 Proxy 链接
    return Reflect.get(target, key, receiver)
  },

  // 拦截数据的赋值操作
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver)
    trigger(target, key)
    // set 方法需要返回一个 boolean
    return result
  }
})
```

:::

### 4.4 分支切换与cleanup

[4.4 分支切换与cleanup](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

`分支切换`：例如一个三元表达式`res.data ? true : false`，根据`res.data`值的不同，会执行不同的代码分支，这就是分支切换。

分支切换可能会产生遗留的副作用函数。如下面这个代码：

```js{11}
cosnt data = {
  ok: true,
  text: "hello"
}

const dataProxy = new Proxy(data, {
  // ... 一些代理的代码
})

effect(function () {
  document.body.innerText = dataProxy.ok ? dataProxy.text : 'not'
})
```

这段代码中，`dataProxy.ok`和`dataProxy.text`都绑定了`effectFn`，但是实际上，`dataProxy.text`由`dataProxy.ok`决定触发与否，即这里的理想情况为`dataProxy.text`的依赖集合中不应该收集这个`effectFn`，但是目前代码的实际情况却并不是如此的，即产生了遗留的副作用函数。它导致的问题为：当`dataProxy.ok`为 false 时，我们修改`dataProxy.text`的值也会触发这个`effectFn`。

**要解决这个问题的整体思路是：每次副作用函数执行时，我们先将它从所有与之关联的以来集合中删除，当副作用函数执行完毕后，重新建立联系，但在新的联系中不会包含遗留的副作用函数。**

因此我们首先需要修改注册副作用函数的`effect`函数，如下：

```js{5-11}
// 用来存储被注册的副作用函数
let activeEffect = null
// effect 函数用来注册副作用函数
function effect(fn) {
  const effectFn = () => {
    // 当 effectFn执行时，将其设置为当前激活的副总用函数
    activeEffect = effectFn
    fn()
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}
```

这个修改的主要思路是添加了`effectFn.deps`，它是一个数组，用来存储所有包含当前副作用函数的依赖集合。然后我们修改上面提取出来的`track`函数，让`effectFn.deps`能收集这些依赖集合：

```js{21-22}
// 在 get 方法中调用，追踪变化
function track(target, key) {
  // 没有 activeEffect，直接 return
  if (!activeEffect) return Reflect.get(target, key, receiver)
  // 根据 target 从 bucket 中取 depsMap，它也是一个 Map 类型
  // key -> effects
  let depsMap = bucket.get(target)
  // 如果 depsMap 不存在，根据 target 新建一个
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
  // 里面存储着所有与当前 key 相关联的副作用函数
  let deps = depsMap.get(key)
  // 如果 deps 不存在，根据 key 新建一个
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 最后将当前激活的副作用函数存入 deps 中
  deps.add(activeEffect)
  // 将 deps 添加到 effectFn.deps 数组中。这里的 deps 就是我们想要的依赖集合
  activeEffect.deps.push(deps)
}
```

完成`track`函数的改造后，我们就收集到了我们想要的依赖集合，它们保存在`effectFn.deps`中，因此我们就可以继续修改`effect`函数了，添加一个`cleanup`函数，用来将副作用函数从依赖集合中清除：

```js
// cleanup 用来将副作用函数从依赖集合中清除
function cleanup(effectFn) {
  const len = effectFn.deps.length
  for (let i = 0; i < len; i++) {
    // 取出依赖集合
    const deps = effectFn.deps[i]
    // 将 effectFn 从这个集合中清除
    deps.delete(effectFn)
  }
  // 重置 effectFn.deps 数组
  effectFn.deps = []
}
```

在`effect`函数中调用`cleanup`方法：

```js{4}
function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 方法
    cleanup(effectFn)
    // ... 其他代码
  }
  // ... 其他代码
}
```

在完成以上步骤后，此时运行代码会发现进入了死循环，这是因为**我们在`trigger`方法中遍历了`Set`类型，即遍历了有`effectFn`的依赖集合，但是在`effectFn`的运行时将其从这个集合中去掉了，完成后又添加了进去。**可以简单理解为如下这个代码：

```js
const set = new Set([1])

set.forEach((item) => {
	set.delete(1)
	set.add(1)
	console.log("遍历set")
})
```

这就会造成死循环。

::::: warning

这个问题在语言规范中描述如下：

**在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。**

:::: details 解决办法如下：

再构造一个`Set`并遍历它

```js{2,4}
const set = new Set([1])
const newSet = new Set(set)

newSet.forEach((item) => {
	set.delete(1)
	set.add(1)
	console.log("遍历set")
})
```

这里大家肯定会有点疑问，这个新的`Set`套了一个旧的`Set`，它俩数据结构都不一样，这个新的代替旧的遍历有什么用呢？其实不是啊，当我们把一个`Set`作为参数传递给另一个`Set`时，它俩的数据结构都是一样的，如下是上面`set`和`newSet`的输出：

::: center

![image-20230315152652086](./第二篇响应系统.assets/image-20230315152652086.png)

:::

::::

:::::

现在我们来改造`trigger`函数解决这个死循环问题：

```js{8-10}
// 在 set 方法中调用，追踪变化
function trigger(target, key) {
  // 根据 target 取出 depsMap
  const depsMap = bucket.get(target)
  if (!depsMap) return
  // 根据 key 取出所有副作用函数
  const effects = depsMap.get(key)
  const newEffects = new Set(effects)
  // 代替 effects 进行遍历
  newEffects.forEach(effectFn => effectFn())
}
```

现在，这套代码就可以按照预期运行了。

### 4.5 嵌套的 effect 与 effect 栈

[4.5 嵌套的 effect 与 effect 栈](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

`effect`是可以发生嵌套的，如`effect(function() { effect(function() {}) })`。具体场景如：在 Vue 中，一个组件里面使用了另一个组件，这就会造成`effect`的嵌套，**因为 Vue 的渲染函数就是在一个`effect`中执行的**。所以`effect`需要设计成可嵌套的，但是目前我们实现的代码并不能支持这一功能，原因就在于`activeEffect`这个变量上。

`activeEffect`这个变量是我们用来存储通过`effect`注册的副作用函数的，但是，它目前是一个全局变量，因此就导致我们每次存储的副作用函数只能有一个，当产生`effect`嵌套时，内层的副作用函数就会覆盖外层的，所以，我们需要一个栈类型的变量来存储这些要注册的副作用函数，因此，我们对`effect`和`activeEffect`的改造如下：

```js{3-4,12-13,15-17}
// 用来存储被注册的副作用函数
let activeEffect = null
// 这是一个副作用函数栈，用来存储要注册的副作用函数
let effectStack = []
// effect 函数用来注册副作用函数
function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 方法
    cleanup(effectFn)
    // 当 effectFn执行时，将其设置为当前激活的副总用函数
    activeEffect = effectFn
    // 将注册的副作用函数压入栈内
    effectStack.push(effectFn)
    fn()
    // 在这个副作用函数执行完后，将其从栈内取出，
    // 这是为了解决嵌套 effect 时，内层的副作用函数执行完后能正确使用外层的副作用函数
    effectStack.pop()
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}
```

### 4.6 避免无限递归循环

[4.6 避免无限递归循环](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

这个问题简单来说就是避免`effect`函数自动的无线嵌套导致栈溢出。这种情况其实在使用时很容易遇到，如下：

```js{7-8}
const data = {
  count: 1
}

const dataProxy = new Proxy(data, { /* 其他代码 */ })

effect(() => dataProxy.count++)
// dataProxy.count++ 相当于 dataProxy.count = dataproxy.count + 1
```

这里我们在`effect`中使`dataProxy.count`自增，这就会导致我们我们读取`count`时触发`get`将副作用函数收集到栈中，然后给`count`赋值时触发`set`将副作用函数取出来执行，但是目前它本身就还在执行过程中，因此就又触发了`dataProxy.count++`，这就会无限递归下去，导致栈溢出。

这个 bug 其实不难解决，因为我们能发现这里问题的关键就在于在`get`和`set`中执行的都是同一个副作用函数，因此，我们只要在`set`中添加一个判断条件：当这个副作用函数正在执行时，就不在`set`中执行它。代码如下：

```js{9-16}
// 在 set 方法中调用，追踪变化
function trigger(target, key) {
  // 根据 target 取出 depsMap
  const depsMap = bucket.get(target)
  if (!depsMap) return
  // 根据 key 取出所有副作用函数
  const effects = depsMap.get(key)
  const newEffects = new Set()
  // 循环判断副作用函数
  effects && effects.forEach(effectFn => {
    // 如果目前 trigger 触发的这个副作用函数不在执行，则继续它的执行步骤
    // 否则不执行任何操作
    if (effectFn !== activeEffect) {
      newEffects.add(effects)
    }
  })
  // 代替 effects 进行遍历
  newEffects.forEach(effectFn => effectFn())
}
```

### 4.7 调度执行

[4.7 调度执行](https://weread.qq.com/web/reader/c5c32170813ab7177g0181aekd3d322001ad3d9446802347?) 

`可调度性`：当`trigger`方法触发时，或者说当被`Proxy`中的`set`行为被触发从而导致`effect`执行时，我们有能力决定它执行的**时机、次数和方式**。这对于一个响应式系统来说是很重要的特性。



## 第五章 非原始值的响应式方案



## 第六章 原始值的响应式方案

